# Managing Users

## Understand the normalized user profile + user metadata

### Metadata in user profiles
* Why
  * Store application specific data
  * Really good if you want to record what's happened/operations/workflows completed for a user
  * Cache the results of expensive operations
  * Overrides the data provided by an identity provider
* When (to update)
  * During login flow
* Types
  * User information
    * description: preferences that don't impact functionality
    * editable by user: YES
    * secure: NO
    * where: user_metadata
  * Access information
    * description: permissions, auth0 plan, external IDs, impacts access to features
    * editable by user: NO
    * secure: YES
    * where: app_metadata
  * Application information
    * description: info about application; extra info not stored in application configuration
    * editable by user: NO
    * secure: YES
    * where:
      * client_metadata in Client object
      * context.clientMetadata in Rules
      * event.client.metadata in post-login actions
* How - via any SDK, dashboard or management API
  * Best way to update is via post-login Action
  * additionalSignUpFields variable can extra fields to classic customised login that updates user_metadata
  * Custom databases - /dbconnections/signup - has a user_metadata field
* Limitations
  * 10 fields of 500 characters each

### Normalised user profile structure
* Metadata - see previous section
* Details - name, email, last user login timestamp, user source connection
  * name
  * nickname - default: local part of user's email
  * picture - URL provided or Gravatar image
  * user_id - subject, created per connection
* DenyList - list of attributes you don't want auth0 to store due to privacy concerns
  * Only done via management API via PATCH call to connections endpoint
  * e.g.
    ```bash
    curl --request PATCH \
      --url 'https://{yourDomain}/api/v2/connections/YOUR_CONNECTION_ID' \
      --header 'authorization: Bearer YOUR_TOKEN' \
      --header 'content-type: application/json' \
      --data '{"options": {"non_persistent_attrs": ["ethnicity", "gender"]}}'
    ```
  * Limitations
    * Only root fields can be denied - only user.name and user.phone_number however they are still stored but not visible on token
    * Denied (but persisted) values cannot be mapped to a custom token claim
    * 
* Social IdP data
  * not directly editable by default. Updated by IdP during login flow automatically
  * to edit - configure 'Sync user profile attributes at each login' (authentication > social > {connection} > advanced) 
    off so that IdP data is only updated on user profile creation
* Validation - Auth0 has validation validation rules for selected user profile attributes 
  * e.g. email - ^(([^<>()[]\.,;:s@"]+(.[^<>()[]\.,;:s@"]+)*)|(".+"))@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}])|(([a-zA-Z-0-9]+.)+[a-zA-Z]{2,}))$
  * all values managed by Auth0 are converted to lowercase. Managed outside of Auth0 are left as is
* Password hashes - not part of user profile (password_hash & custom_password_hash)
* Identities section list additional secondary identities (including primary) linked to the user. Each entry contains
  * connection e.g. google-oauth2
  * isSocial e.g. true
  * provider e.g. google-oauth2
  * user_id e.g. 115015401343387192604
  * Primary - located one level up in user_id e.g. google-oauth2|115015401343387192604 (this is the destination identity that every other identity was linked/mreged into) 
    

## Configure user account linking functionality
* Benefits
  * Allows users to link multiple accounts to a **SINGLE** profile (no need to create multiple profiles)
  * Allows registered users to use a new social or passwordless login but continue using their existing profile
  * Allows apps to retrieve user profile data stored in various connections
  * SSO enabled/shared across linked accounts
* Risks
  * Linking accounts can allow attackers to high-jack user accounts/profiles (must authenticate both accounts before linking)
* Limitations
  * Metadata of the secondary account is not merged (but discarded) into the primary acocunt during linking, you have to do that manually via management API before linking accounts
* Prerequisites
  * User must have access token with permission: update:current_user_identites
* Flow
  1. User logs in via Universal login
  2. User goes to their profile/settings page
  3. User clicks link account button
  4. User is redirected to Universal login with additional query parameter `connection=YOUR_CONNECTION_ID`
  5. Use the returned token to call the 'Link a User Account' endpoint via the Management API
     ** User/client initiated ** - Note primary account is the one used in the Authorisation header
     * End user requires update:current_user_identites permission
      ```http request
      POST /api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities
          Authorization: "Bearer PRIMARY_ACCOUNT_JWT" // <- ID Tokens are deprecated. For future use Access Tokens
          {
          "link_with": "SECONDARY_ACCOUNT_JWT"
          }
      ```
      * ** Server initiated ** - link accounts without going through Universal login (see example below with actions using this)
      * Server requires update:users permission
      ```http request
      POST /api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities
          Authorization: "Bearer YOUR_API_V2_TOKEN"
          {
            "provider": "SECONDARY_ACCOUNT_PROVIDER",
            "connection_id": "SECONDARY_ACCOUNT_CONNECTION_ID(OPTIONAL)",
            "user_id": "SECONDARY_ACCOUNT_USER_ID"
          }
      ```
* Alternate flow (use actions)
  1. Post-login action identifies potential user accounts for linking (if they exist) using management API getUser
  2. Action redirects user to external linking application with a token payload that contains the candidate user identities e.g.
    ```json
    {
      "current_identity": {
        "user_id": event.user.user_id,
        "provider": event.connection.strategy,
        "connection": event.connection.name
      },
      "candidate_identities": [
        {
          "user_id": USER_ID_1,
          "provider": PROVIDER_1,
          "connection": CONNECTION_1
        },
        {
          "user_id": USER_ID_2,
          "provider": PROVIDER_2,
          "connection": CONNECTION_2
        },
        ...
      ]
    }
    ```
  3. External linking application prompts the user to authenticate using creds for the account they want to link to the primary account
  4. External linking application redirects user back to Auth0 with a token payload containing the primary and secondary user identities
    ```json
    {
      "primary_identity": {
        "user_id": PRIMARY_USER_ID,
        "provider": PRIMARY_PROVIDER_STRATEGY,
        "connection": PRIMARY_CONNECTION_NAME,
      },
      "secondary_identity": {
        "user_id": SECONDARY_USER_ID,
        "provider": SECONDARY_PROVIDER_STRATEGY,
        "connection": SECONDARY_CONNECTION_NAME,
      }
    }
    ```
  5. Action validates the authenticity and contents of the token
  6. Action calls management API to link the accounts based on the results from the external linking application
  7. Action switches to primary user if it doesn't match the event.user.user_id
  
## Implement user process and Progressive profiling
* Tips
  * If your solution will not evolve - Checkout Auth0 Market place first as there is likely already a solution for your use case
  * Only use if you have little time and budget - otherwise build your own flows outside of Auth0
  * Use dashboard > actions > forms to collect user data hosted by Auth0
* Limitations: Vendor lockin to Auth0 - more work to migrate when costs spiral
* Benefits
  * Avoids large upfront sign up forms that impact customer experience
  * If experience is good - helps with conversion rates?
* What is it
  * Progressively collecting information about your users as they engage with your application
  * e.g. When they login you get user name, email and password and then next time they login ask for company name, job title etc.
* Flow (Oh boy this is interesting)
  1. Create Post login action checks 'profile gathering app' data present and user is logging in for second time
     * secret - event.secrets.SESSION_TOKEN_SECRET (generate using `openssl rand -hex 32`)
     * link to form - events.secrets.FORM_URL (probably doesn't need to be a secret)
     * count - event.stats.logins_count > 1
     * Check if you have the data your need e.g. `const current_first_name = event.user.user_metadata["first_name"] ?? undefined;`
  2. In Action - Add logic for creating JWT token for authenticating and moving data and redirect to form e.g.
    ```javascript
    exports.onExecutePostLogin = async (event, api) => {
      const sessionToken = api.redirect.encodeToken({
        secret: event.secrets.SESSION_TOKEN_SECRET ,
        payload: {
            iss: `https://${event.request.hostname}/`,
            subject: event.user.user_id,
            audience: event.secrets.FORM_URL,
            expiresIn: '5 minutes',
            data: prog_profile // This is kinda cool. It contains meta about the questions to ask, the theme to use and data from event.user.user_metadata['thing']
        }
      });
      // PERFORM REDIRECT TO EXTERNAL PAGE WITH SESSION TOKEN
      api.redirect.sendUserTo(event.secrets.FORM_URL, {
        query: {
          session_token: sessionToken,
          redirect_uri: `https://${event.request.hostname}/continue`,
        }
      });
    }
    ```
  3. Form gathers information and redirects back to provided continue redirect uri `https://${event.request.hostname}/continue` 
     * This is magic to me. Actions have their own ENDPOINTS!!!
  4. Action validates JWT token and extracts data from payload and updates user metadata 
     * Alternative - calls 'YOUR' api to update data in profile service using same token used previously
    ```javascript
    exports.onContinuePostLogin = async (event, api) => {
      const app_metadata_values = [];
      const skipped_claims = ["user_info_skipped", "state", "action"];
      let decodedToken;
      try {
        decodedToken = api.redirect.validateToken({
            secret: event.secrets.SESSION_TOKEN_SECRET,
            tokenParameterName: 'session_token',
        });
      } catch (error) {
        return api.access.deny('Error occurred during redirect.');
      }
      var customClaims = decodedToken.other;
    
      // Set response values into the user metadata or app metadata.
      for (const [key, value] of Object.entries(customClaims)) {
        console.log(key);
        if (!skipped_claims.includes(key)) {
          if (app_metadata_values.includes(key)) {
            api.user.setAppMetadata(key, value);
          }
          else {
            api.user.setUserMetadata(key, value);
          }
        }
      }
  
      // Check if First Name, Last Name, City not entered and flag for next time.
      var user_info_missed = true
      if (customClaims["first_name"] && customClaims["last_name"] && customClaims["city"]){
          user_info_missed = false;
      }
      api.user.setAppMetadata("user_info_missed", user_info_missed);
    };
    ```
### Profile enrichment
* A technique where additional user information is gathered from publicly available 3rd party sources to enhance the user profile

## Implement organizations and access control/role
* GOTCHA
  * Auth0 has fucked up ideas about describing tenancy with organisations
    * They refer to **MULTI-TENANCY** as using Auth0 as a **SINGLE** tenant with multiple 'organizations'
    * **MULTI-TENANCY** to Auth0 is a always referred to as your STUFF being multi-tenanted... but theirs being **SINGLE** tenancy fuck!!
    * It's so messed up because it assumes you have to use multiple tenants to achieve multi-tenancy but they don't, 
      they'll just use organisations to achieve multi-tenancy
  * Organisations are not a replacement for tenants
* Why - allow B2B customers to better manage their partners and customers by
  * providing customisation for how end users access apps and APIs (very limited)
  * some level of separation â€“ user pools
  * provide some administrative control to those businesses can manage their own organisations
  * roles can be assigned to users at the organisation level for different levels of access. I.e. when they login they 
    get special roles due to membership with that org (kinda cool :) )
* Scenarios
  * product that is licenced to another business for use by their employees
  * Default: users are part of a single organisation (default org)
  * Not default: users like freelancers or contractors may move between organisations or be part of multiple organisations
* Planning considerations
  * Login experience - customisation, have to select org when logging in?
    * Default: Prompted for identifier first and org selected automatically based on email or user_meta
    * 3 types
      * Prompt for credentials (identifier first) - org automatically selected based on email or user_meta or they choose org when user is member of multiple orgs
      * Prompt for org first - same as above but user is prompted to select org first before entering credentials
      * No prompt for org - org is sent programmically in request to /authorize endpoint
  * Connection model - any users shared between orgs? Do orgs needs to use their own IdP? You can add connections to orgs
    * 3 types (set at the application level)
      * Individual - only individuals can use app
      * Organisation only - only members of an org can use app
      * Both - members of an org can use app and individuals can use app
  * Roles - do orgs have their custom roles? You could create a custom dashboard for them to self manage these as well as 
    access to some parts of management API - just assign at last 2 of them admin roles to do this
* Adding users to orgs (3 types)
  * Auto-membership (Just in time membership - good if connection is trusted i.e enterprise connection)
    * when disabled users are not added to org on loging (great if adding connection to org temporarily)
    * when enabled users are added to org on login (great if adding connection to org permanently)
  * Email invitation - send email to user with link to accept invitation. Can assign connections and roles to user at this point
  * Invite user via management API / Dashboard- can assign roles to user at this point
    * POST to `/api/v2/organizations/{id}/members` with body `{"members": \["auth0|user1", "google-oauth2|user2"\]}` with comma delimited list of subjects
    * Limit - only 10 members per post call - this is so low.... lame
* Org stored in token as 
  * org_id - must be validated by API when validating any tokens
  * org_name - can be added by configuring in dashboard > tenant settings > advanced > settings > 'Allow Organization Names in Authentication API'
* How to specify an org
  * Must add org parameter org_id to /authorize endpoint call OR get end-user to select org on universal login page
  * M2M apps must use Client Credentials grant and pass org_id in request body
    * Default orgs - Some clients do not support non-standard fields like org_id so you can set a 'default org' instead
      * M2M App/API duo has to set organisational support to 'Required'
      * Location - organisations > select org > select Machine to Machine Access > select App > select API
* Defining orgs
  * Connections: You can choose to auto-add members from a connection OR just allow temporary access by not auto-adding them
  * M2M: You can add applications (apps can be configured to indicate how much access to orgs they can have, see Association)
* Association
  * Applications
    * app > Login Experience > select organisation
  * M2M apps (only use Client Credentials grant)
    * select M2M app > select APIs tab > for each API select EDIT > set 'Organisation Support
      * None - any org can use this API (via this M2M app)
      * Optional - any org can use this API (via this M2M app)
      * Required - only orgs can access this API (via this M2M app)
* Limitations
  * Only universal login is supported
  * Cannot use Resource owner grant, Password grant or Device authorisation flow, WS-Fed (Auth0 as Idp)
  * No custom domains per organisation - otherwise use multiple tenants
  * no integration with delegated administration extension
  * no integration with authorisation extension
  * no integration with 3rd party applications

## Design and implement user session management
* Location - select tenant > Settings > Advanced > Session Expiration
  * Persistent
    * Idle - Time user is idle before session expires (default 4320 seconds = 1.2 hours)
    * Max - Time session exists in total regardless of use (default 10080 seconds = 2.8 hours)
  * Non-Persistent
    * Idle - Time user is idle before session expires (default 1440 seconds = 0.4 hours)
    * Max - Time session exists in total regardless of use (default 4320 seconds = 1.2 hours)
* Dynamic changes via Post-login Actions
  * Override default tenant session settings on a 'per login basis'
  * using api.session.setExpiresAt / api.session.setIdleExpiresAt / api.session.setCookieMode
* Session management via Management API
  * Delete session - instantly invalidates session and logs them out next time they attempt to call /token endpoint
* Refresh token management via Management API
  * Delete session - instantly invalidates token and results in authentication next time refresh token is used (unless Rotation Overlap Period used)

## Implement session management APIs
* Handled by previous section

## Role based access control (RBAC) - (Actually ABAC in disguise due to use of permissions)
* Tips
  * When assigning roles always adhere to the principle of least privilege
* VERY IMPORTANT
  * When RBAC is disabled - an application can request any permission defined for the API, scope claim of the access 
    token includes all permissions defined for API (this is a feature toggle, otherwise you just get back the scopes you asked for)
  * When RBAC is enabled - the scope claim of the access token includes an intersection of the requested permissions and the permissions assigned to the user
    * If you want all permissions assigned to the user in the permissions claim of the access token - enable the **'Add Permissions in the Access Token'** opttion in API settings
      * this allows you to reduce the number of calls to get access tokens containing the scopes you require but **increases token size**
    * Requested permissions are defined via the scopes parameter when calling /authorize endpoint
    * STEP UP AUTHENTICATION - Best practice only ask for permissions you need. Use 'step up authenticaiton' for higher level access e.g. 
      you can login with creds for customers page but accessing employees page requires MFA check and at this point you can 
      request more permissions via RBAC
* Structure - Permissions > Roles > Users
* Permissions
  * are not duplicated in JWT token. Result is union of permissions from assigned user roles
  * are equivalent to scopes
  * are scopes that can be added to roles
  * can be manually added to individual users (user management > users > select user > Permissions)
* Flow:
  1. Add scopes to API
  2. Enable RBAC on API (APIs > settings > Enable RBAC)
  2. Create Role
  3. Assign Permissions to Role by chooseing APIs and selecting their scopes
  4. Assign 
* Rules extend existing functionality
  * Temporary access
  * Conditional access based on meta data or other attributes
  * Time based access due to holidays etc...
* Limitations
  * Vendor lock in with Auth0
* APIS
  * Allow Skipping User consent - If enabled, API will skip user consent for applications flagged as First Party.

### Scopes
* OAuth 2.0 is an authorisation protocol
* Structure: scopes > API
* 3rd parties are always prompted for consent of request scopes by client for use with API
* If first party application - then consent is not required by default but can be set to requested