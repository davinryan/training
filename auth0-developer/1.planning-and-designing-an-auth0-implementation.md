# Planning and Designing an Auth0 Implementation
Exam questions in this domain test the understanding of Auth0’s architectural building blocks and the security implications of fundamental configuration choices

## Authentication (B2B)
How authentication works in your B2B IAM implementation. What is meant here is not true B2B but B2B between your application and Auth0

* Client type - m2m authorisation
* Universal login
  * Redirects to the correct application (via client id)
  * Provides Branding
  * Dictates authentication lifecycle type
* IdP - identity provider
* Connections/Realms/IdP - sources of users
  
### Home Realm discovery (HRD)
* the process of identifying which identity provider (or which connection in Auth0) the user belongs to before authenticating them

#### Decision made at application (basically just send query parameters)
* Options for choosing Realm
  * (user part of single org) can use a custom hostname (companyA.application1.yourcompany.com) or path (application1.yourcompany.com/companyA)
  * (user part of multiple orgs) turn on 'Home Realm Discovery on the Universal Login Page' - Universal login provides options to user
  * provide IdP (connection) as part of call to /authorize via ?connection= query parameter
  * provide organisation as part of call to /authorize via ?org_id= query parameter (all this does is limit the connections available to the application)
    
#### Decision made at server (basically Universal login figures it out)
* Options for choosing Realm
  1. Via user's email subdomain to map to realm (only works when user has 1:1 mapping with realm)
    * Need to build/setup mapping of email subdomain -> connection
    * if org_id not provided, Auth0 will prompt user to choose organisation
    * if organisation has more than one associated connection, Auth0 will prompt user to choose organisation or provide username & password
  2. Look up user's identifier (subject) in map of identifier -> realm
     * Host map on a publicly accessible endpoint - downside is latency, extra call to get this information
  3. Allow user to choose to enter their realm manually ('Home Realm Discovery on the Universal Login Page')
* The first two approaches support 'identifier first' - user provides an identifier and this is used to look up the realm - more complex, not recommended

### Username & password authentication
* Default: Auth0 Database connection

#### Application integration
* Default: Use Auth0 SDKs to avoid hitting rate limits and to avoid making security mistakes in your flow
* Anonymous access - not really anonymous just as the user already signed in previously
  * Deep linking – silently authenticate, redirect to Auth0 if not authenticated and redirect then back again

### Attack protection
* https://auth0.com/docs/secure/attack-protection
* Auth0 built in feature stuff
  * Bot Detection
  * Brute Force Protection
  * Suspicious IP Throttling
  * Breached password detection

### SSO with legacy systems (migration)
* works if you're system's support OIDC or SAML
* take iterative approach e.g. strangler approach
* get legacy system to redirect to Auth0 for authentication OR
* get Auth0 to redirect to legacy system for authentication
* consider federated approach

### Enterprise Login (bring your own identity)
* not a thing really - just allowing social logins with HRD to determine connection/identity provider
* advice if you're going to use, do it early so you don't have to play the 'linking' game

### MFA
* tip - make it optional for users to add MFA rather than forcing them
* tip - if app is mobile app/device only, consider building MFA into app experience
* Options
  * Auth0 Guardian - God help us - you have no control over this, its propietary, sucks to be you if you don't like the app or it doesn't work for you
  * Time based one-time password (TOTP) - just the usual stand approach
  * SMS - God help us - So insecure, very easy to intercept text messages
  * Voice - God help us - AI can immitate human speech
  * Email - God help us - So insecure, very easy to intercept with man in the middle attack
  * Duo - same problem as Auth0 Guardian

### Multiple Organisation architecture (multi-tenancy)
* basically to provide isolation between organisations

## Organizations: Assign Members to an Organization
* remember organisation is just a meta group of users from various connections
* add user by adding their id to organisation (Management API supports list of user ids, Dashboard just one user id)

## Organizations: Invite Organization Members
* In order to make this work (if your app initiates invite, not Auth0)
  1. Configure URI - set login URL filter to allow invite for application
  2. Specify route behaviour - update app to call login URL with invitation ticket id and organization id e.g. https://myapp.com/login?invitation={invitation_ticket_id}&organization={organization_id}&organization_name={organization_name}
  3. Customise user invitation flow - Provide any branding in Auth0 templates so that the email sent is appropriate for your app
* Invites can also be sent from Auth0 dashboard or management API

## Actions: Pre-User Registration Flow
* Type of Auth0 'action' of type 'trigger'
* It can be used to add metadata to the user profile before it is created or to deny a registration
* The Pre-user Registration trigger runs before a user is added to a Database or Passwordless Connection.
* SDK Function: exports.**onExecutePreUserRegistrationasync** (event, api) => { // User allowed to sign up only if north american
    if (event.request.geoip.continentCode === "NA") {
    ...
    const userMessage = LOCALIZED_MESSAGES[event.request.language] || LOCALIZED_MESSAGES['en'];
    **api.access.deny**('no_signups_from_north_america', userMessage);
* SDK Function exports.**onExecutePreUserRegistration** = async (event, api) => {
    api.user.**setUserMetadata**("screen_name", "username");  
  };

## The OAuth 2.0 Spec: 2.1. Client Types
* Confidential Clients - require a client secret e.g. M2M, Regular Web app
* Public Clients - no client secret e.g. SPA, Native App

## Authentication and Authorization Flows
* Authorisation code flow - client id and secret to get access token
* Authorisation code flow with proof key for code exchange - same as Auth code flow but client secret replace with code challenge
* Authorisation code flow with enhanced privacy protection - what the hell is this?
* Implicit flow with form post - deprecated
* Hybrid flow - finally they have PKCE where we can get ID Token without having to get an access token!!!!!
* Client credentials flow - used for server to server communication
* Device authorization flow - used for mobile apps
* Resource owner password flow - used for CLI apps (basically just username & password)
* Client initiated backchannel authentication flow - used for mobile apps
* Custom token exchange - basically just using existing flow above and then manually call /oauth/token endpoint to access
  another audience on the user's behalf

## Deployment Options - Deploy on private or public cloud
* For enterprise tier only
* Public cloud - AWS only, multi-tenant
  * AWS shared tenant
  * Availability: US, UK, EU, Australia, Japan, Canada
  * Updates: automatic
  * Use case: B2B, SaaS and Retail
* Private cloud – Azure or AWS, single tenant only
  * higher performance, higher isolation, easier cheaper dev instances
  * Can provide a guaranteed level of requests per second 
  * Geo-HA add-ons: Geo-failover, PCI compliance
  * Availability: 60 countries
  * Updates: manually by customer
  * Use case: Fintech, Healthcare, Government

## Multi-Tenant Applications Best Practices
* Auth0 recommends Auth0 Organisations (Groups of Users with tailed experiences) (this feels dumb for dev, test environments when you would most likely use a single tenant)
* Use cases
  * product licenced to another business
  * multiple orgs that need their own branding and auth experience
  * separate levels of access for different groups of users
* Legacy solutions
  * Challenge: if licencing to another business, how do you control licencing administration. Orgs only works if you 'own' administration
  * Auth0 connection, Auth0 application, Auth0 tenant (WHY? this is really good), storing tenant details in user's profile (Super dumb)
* Limits: 50 databases connections per application

## Validate Access Tokens
* JWT access tokens
  * use public certificates to validate signature
  * check expiry
  * check audience
  * verify permissions (scopes)
* Opaque tokens - Auth0 validates this when you send opaque token to Auth0

## Configure Refresh Token Rotation
* Refresh tokens are valid for a longer time making it easier to get multiple access tokens without having to reauthenticate the user
* Rotating (new): Every time a refresh token is used to get an access token, a refresh token is also returned (hence rotated)
* Auth0 will automatically swap out non rotating one for a rotating one (SDK will) when you change configuration to rotating
* Default: Auth0 SDK rotates if you use refresh tokens
* Default: if a token fails to validate then all tokens including refresh tokens are nuked

## Authorization Code and Access Token Variable Size Information
* Affects Auth0 opaque access tokens
* Major recent change
  * Previous Fixed Code length: 16 Chars 
  * New Behaviour: Currently, the Max is set to 45 Characters, but this is an implementation detail and can be changed.
* Auth0 Recommendation: not to rely on token size (this feels like a bad idea as it could result in DOS attacks)

## Token Best Practices
* Keep private signing keys safe – duh
* Don't add sensitive information to tokens
* Give tokens an expiry time
* Use HTTPS
* Store & reuse tokens
* Tokens vs cookies - if api and web app are on same domain just use cookies
* Refresh token usage
  * Flows - auth code flow, PKCE flow, Resource owner flow and device auth flow
  * offline access = no refresh token even if API request asks for it
  * rules will run for refresh token exchange (use context.protocol in custom rule, if equal to oauth2-refresh-token then rule is running during exchange)
  * audience parameter is not available on rules context object. You will get an error setting it if it already exists on token
  * if you try to redirect with with context.redirect the auth flow will return an error
  * if you added custom claims to token using rules, those claims will appear in new tokens issued by refresh token. Doesn't matter if refresh token is old or new
  * Limits: 200 'active' tokens per user per application. If limit reached, requesting a new refresh token will expire the oldest one first
  * Automated tests: will accumulate refresh tokens. Use the management API to delete them
  * https://auth0.com/docs/api/management/v2/device-credentials/get-device-credentials - can be used to get list of refresh tokens
  * https://auth0.com/docs/api/management/v2/device-credentials/delete-device-credentials-by-id - delete refresh token by id
  * Obsolete refresh tokens get created when a user logs in multiple times in a short period of time
  * Auth0 recommendation: Instead of manually deleteing refresh tokens just set **an expiry** time
* JWT Validation
  * Use middleware (JWT.io for validation SDK) - duh
  * Signing algorithms
    * RS256 - public apps
    * HS256 - confidential apps
    * Auth0 recommends RS256: one holder of private key; request token for multiple audiences; private key compromised just rotate key (no app redeployments required)
  * Signing Keys
    * multiple keys will be present in JWKS due to rotation of signing keys
    * cache these to improve performance, token validation failure shoudl result in cache invalidation (only one time) 

## Technical Strategies for Migrating Users to Auth0
### Features
* Import of Hashed user passwords available if they use a supported hash algorithm (https://auth0.com/docs/manage-users/user-migration/bulk-user-import-schema#supported-hash-algorithms)
* 
### Methods
* Bulk import of users - via management API or import/export extension
  * Reasons: urgency; deprecation of old system; old system obsolete, buggy, not compliant; old system licencing fees too expensive
  * Risks: may require multiple imports to capture all users; password hash may not be supported
  * Typical approach
  * Requires migration from exported schema to Auth0 schema (https://auth0.com/docs/manage-users/user-migration/bulk-user-import-schema)
  * Custom hash password can be provided in import schema to support hashed passwords
  * Features: can disable sign ups; require usernames instead of email
  * Requires management API scopes: create:users, read:connections
  * Flow (management API): call management API to import users; store returned id; wait for long running job to complete (use id to query progress);
  * Flow (import/export extension): install extension; upload JSON file; wait for long running job to complete
* Automatic (progressive) migration - via custom database connections (users are migrated only when they sign in)
  * Reasons: When its too hard to export data from existing system; great way to purge inactive users
  * Risks: not great if system has inactive/dormant users that you want to keep; password hash may not be supported; large time frame to migrate
  * When olds system is not immediately being deprecated
  * System must be available from the public internet (Auth0 can't access private systems)
  * How works: custom hooks written in javascript to call IdP API to get user details;
  * Flow: login in via Auth0; auth0 checks if user exists in Auth0; if so, login; if not call custom script to get user details from other IdP and store in Auth0
* Use your own user store
  * Reasons: Auth0 try before you by; forced to keep user store
  * Basically just migrate platform not data
  * Requires custom database
  * User store must be available from the public internet (Auth0 can't access private systems)
* Options
  * Automicate migration followed by bulk migration when you're ready to say goodbye to legacy IdP

### Precautions
* secure legacy public access - build a layer between world and legacy IdP
* import password hashes - to reduce friction
* enforce strong passwords - increase password lengths
* implement MFA
* 

## User Migration Your Way
