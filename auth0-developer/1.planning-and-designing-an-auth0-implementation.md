# Planning and Designing an Auth0 Implementation
Exam questions in this domain test the understanding of Auth0’s architectural building blocks and the security implications of fundamental configuration choices

## Authentication (B2B)
How authentication works in your B2B IAM implementation. What is meant here is not true B2B but B2B between your application and Auth0

* Client type - m2m authorisation
* Universal login
  * Redirects to the correct application (via client id)
  * Provides Branding
  * Dictates authentication lifecycle type
* IdP - identity provider
* Connections/Realms/IdP - sources of users

### Universal Login
* Server side rendered
* Classic - deprecated (not server side rendered)
* Customised - via management API & dashboard. Uses Liquid templates for all pages
* Passwordless login - WebAuthN (e.g. Passkeys), Biometrics
* login_hint - query parameter to pre-populate username/email field for ease of use
* Passkeys - also available as an authentication method for database connections
* MFA - can be customised with Actions and user metadata can be leveraged to create more individualised experiences
* Sign Up
* Password Reset - can be customised with Actions to provide secondary challenge
* Custom databases - if error when changing password, will still be fine even if change password script fails (password in Auth0 just not in custom database I suppose
* Email Verification
* Supports password autocomplete with password managers
* Customised experience - Data capture (extra data from user) & Custom conent (like branding, logos)

#### Branding
* Demo current branding: dashboard > Authentication > Authentication Profile > Try button
* Calling Auth0 Management API with null values resets them to default
* Need test app created to use auth0 interactive documentation to run branding commands
* Use API docs to test out / use branding commands

#### Default Error page
* company friendly name (default: empty)
* Logo URL (default: Auth0)
* Support email (default: empty)
* Support URL (default: empty)
* Debug information: client_id (might be missing if not provided), connection, lang, error_description, tracking (tracking id))
* Common errors:
  * The application's callback URL is invalid (e.g., not included in the list of  allowed callback URLs )
  * Required parameters are missing from a request to the Auth0 Authentication API's  Login endpoint
  * The user navigates to a bookmarked login page and a  Default Login Route  is not defined
  * Your tenant uses Classic Login and the user opens an expired password reset link
* Not displayed: authorisation error and callback URL is valid - error returned to application via query parameters state and error in callback URL
* Can configure to redirect to a custom error page 
  * self hosted (set via auth0 management API or dashboard)
  * Auth0 hosted (PATCH via auth0 management API)) - only available with Universal login (not Classic login)

#### Custom domains
* Brand loyalty
* Application maintenance - centralise authentication services
* Phishing resistant - attackers have to create urls that mimick yours. Much harder when not a machine generated domain
 
#### Email Templates
* Template properties
  * 'only work' when you provide your own custom email provider
  * have access to common variables (tenant, user & application meta data only) (e.g. {{ user.name }})
* Types: (dashboard > branding > email templates)
  * Welcome registered user (sent after verification)
  * Password reset (supports code/link)
  * Email verification (supports code/link, Adaptive MFA - will send if low confidence)
  * MFA enrollment (sent after tenant admin sends Auth0 guardian enrollment email)
  * Blocked account (sent after 10 failed login attempts from same IP address, provides link to unblock account)
  * Password breach (when password is confirmed to be leaked by third party)
  * Verification code for email MFA (Supports code)
  * Invite user (user invited to app or org)
* Formats: HTML with Liquid
* Functions: toggle on/off;
* Typical fields
  * From
  * Subject
  * Redirect To - URL to redirect user to after completing action. Only has access to the application.name and application.callback_domain variables
  * URL Lifetime - default 432000 (5 days)
  * Message - body of template

  
### Home Realm discovery (HRD)
* the process of identifying which identity provider (or which connection in Auth0) the user belongs to before authenticating them

#### Decision made at application (basically just send query parameters)
* Options for choosing Realm
  * (user part of single org) can use a custom hostname (companyA.application1.yourcompany.com) or path (application1.yourcompany.com/companyA)
  * (user part of multiple orgs) turn on 'Home Realm Discovery on the Universal Login Page' - Universal login provides options to user
  * provide IdP (connection) as part of call to /authorize via ?connection= query parameter
  * provide organisation as part of call to /authorize via ?org_id= query parameter (all this does is limit the connections available to the application)
    
#### Decision made at server (basically Universal login figures it out)
* Options for choosing Realm
  1. Via user's email subdomain to map to realm (only works when user has 1:1 mapping with realm)
    * Need to build/setup mapping of email subdomain -> connection
    * if org_id not provided, Auth0 will prompt user to choose organisation
    * if organisation has more than one associated connection, Auth0 will prompt user to choose organisation or provide username & password
  2. Look up user's identifier (subject) in map of identifier -> realm
     * Host map on a publicly accessible endpoint - downside is latency, extra call to get this information
  3. Allow user to choose to enter their realm manually ('Home Realm Discovery on the Universal Login Page')
* The first two approaches support 'identifier first' - user provides an identifier and this is used to look up the realm - more complex, not recommended

### Username & password authentication
* Default: Auth0 Database connection

#### Application integration
* Default: Use Auth0 SDKs to avoid hitting rate limits and to avoid making security mistakes in your flow
* Anonymous access - not really anonymous just as the user already signed in previously
  * Deep linking – silently authenticate, redirect to Auth0 if not authenticated and redirect then back again

### Attack protection
* https://auth0.com/docs/secure/attack-protection
* Auth0 built in feature stuff
  * Bot Detection
  * Brute Force Protection
  * Suspicious IP Throttling
  * Breached password detection

### SSO with legacy systems (migration)
* works if you're system's support OIDC or SAML
* take iterative approach e.g. strangler approach
* get legacy system to redirect to Auth0 for authentication OR
* get Auth0 to redirect to legacy system for authentication
* consider federated approach

### Enterprise Login (bring your own identity)
* not a thing really - just allowing social logins with HRD to determine connection/identity provider
* advice if you're going to use, do it early so you don't have to play the 'linking' game

### MFA
* tip - make it optional for users to add MFA rather than forcing them
* tip - if app is mobile app/device only, consider building MFA into app experience
* Options
  * Auth0 Guardian - God help us - you have no control over this, its propietary, sucks to be you if you don't like the app or it doesn't work for you
  * Time based one-time password (TOTP) - just the usual stand approach
  * SMS - God help us - So insecure, very easy to intercept text messages
  * Voice - God help us - AI can immitate human speech
  * Email - God help us - So insecure, very easy to intercept with man in the middle attack (uses code, magic links not supported)
  * Duo - same problem as Auth0 Guardian
  * Phone message

### Multiple Organisation architecture (multi-tenancy)
* basically to provide isolation between organisations

## Organizations: Assign Members to an Organization
* remember organisation is just a meta group of users from various connections
* add user by adding their id to organisation (Management API supports list of user ids, Dashboard just one user id)

## Organizations: Invite Organization Members
* In order to make this work (if your app initiates invite, not Auth0)
  1. Configure URI - set login URL filter to allow invite for application
  2. Specify route behaviour - update app to call login URL with invitation ticket id and organization id e.g. https://myapp.com/login?invitation={invitation_ticket_id}&organization={organization_id}&organization_name={organization_name}
  3. Customise user invitation flow - Provide any branding in Auth0 templates so that the email sent is appropriate for your app
* Invites can also be sent from Auth0 dashboard or management API

## Actions: Pre-User Registration Flow
* Type of Auth0 'action' of type 'trigger'
* It can be used to add metadata to the user profile before it is created or to deny a registration
* The Pre-user Registration trigger runs before a user is added to a Database or Passwordless Connection.
* SDK Function: exports.**onExecutePreUserRegistrationasync** (event, api) => { // User allowed to sign up only if north american
    if (event.request.geoip.continentCode === "NA") {
    ...
    const userMessage = LOCALIZED_MESSAGES[event.request.language] || LOCALIZED_MESSAGES['en'];
    **api.access.deny**('no_signups_from_north_america', userMessage);
* SDK Function exports.**onExecutePreUserRegistration** = async (event, api) => {
    api.user.**setUserMetadata**("screen_name", "username");  
  };

## The OAuth 2.0 Spec: 2.1. Client categories
* Confidential Clients - require a client to store a secret e.g. M2M, Regular Web app
  * Can use 
    * Client Secret Post (Symmetric) (client id & secret sent in body)
    * Client Secret Basic (Symmetric) (client id & secret sent in headers)
    * Private Key JWT (Asymmetric) (JWT signed with private key, JWT sent with request as header, server uses public key to verify signature)
* Public Clients - no client secret e.g. SPA, Native App
  * PKCE prevents Cross site request forgery (CSRF) and authorisation code interception attacks (just creates a secret to use at runtime like https)

## Authentication and Authorization Flows
* Authorisation code flow - client id and secret to get access token
* Authorisation code flow with proof key for code exchange - same as Auth code flow but client secret replace with code challenge
* Authorisation code flow with enhanced privacy protection - what the hell is this?
* Implicit flow with form post - deprecated
* Hybrid flow - finally they have PKCE where we can get ID Token without having to get an access token!!!!!
* Client credentials flow - used for server to server communication
* Device authorization flow - used for mobile apps
* Resource owner password flow - used for CLI apps (basically just username & password)
* Client initiated backchannel authentication flow - used for mobile apps
* Custom token exchange - basically just using existing flow above and then manually call /oauth/token endpoint to access
  another audience on the user's behalf

## Deployment Options - Deploy on private or public cloud
* For enterprise tier only
* Public cloud - AWS only, multi-tenant
  * AWS shared tenant
  * Availability: US, UK, EU, Australia, Japan, Canada
  * Updates: automatic
  * Use case: B2B, SaaS and Retail
* Private cloud – Azure or AWS, single tenant only
  * higher performance, higher isolation, easier cheaper dev instances
  * Can provide a guaranteed level of requests per second 
  * Geo-HA add-ons: Geo-failover, PCI compliance
  * Availability: 60 countries
  * Updates: manually by customer
  * Use case: Fintech, Healthcare, Government

## Tenants
* Available: Australia; Canada; Europe; Japan; United Kingdom; United States
  * Impacts url generated e.g. example.eu.auth0.com refers to EU tenant
* Limitations
  * Cannot choose sub-locality
  * Not multi-regional unless you use enterprise
* Features
  * Separates/isolates: Auth0 customer data; Development environments
  * Tagged environments: development; staging; production. Impacts cost and availability (higher rate limits)
  * B2C (business to customer)
    * Customers come to you
    * Customers choose how they want to login (social, auth0 account)
  * B2B (business to business)
    * Business (employees) invite you (business partners or guests)
    * Self service signup
  * B2E (business to employee)
    * Employees invite employees
    * for applications used by employees
* Recommendations: 
  * Use single tenant per environment. Environments can be tagged to reduce cost
  * Use orgs for multi-tenant environments (so dumb!)
  * Min of 2: 1 non-prod & 1 prod tenant
* 10 workstreams required to go live (essentially architecture)
  1. Architecture - who are you serving (B2B, B2C, B2E)
  2. Authentication - who are you (MFA recommended)
  3. Authorisation - what can you do (scopes/claims recommended)
  4. Branding - how do you want to look (custom branding recommended)
  5. Deployment automation - how do you deploy (environment tenants recommended, CI/CD pipelines recommended)
  6. Logout - how do you end sessions to reduce attack surface
  7. Operations - how do you monitor, handle business continuity (logs recommended)
  8. Profile management - KYC (Know Your Customer) two types of meta stored: user editable; not user editable (reccommended: never store meta that impacts access control that users can edit)
  9. Provisioning - how will users access your system
  10. Quality assurance - how will you reduce negative impacts to customers (accessibility, different devices/browsers)
* Auth0 believes in architecture visualisations first

### Provisioning tenants
* Required
  * Name
  * Region
  * Environment Tag (default: Development)
* Tips
  * Extensions are per tenant
  * unique name
  * lowercase alphanumeric & hyphens. Cannot begin or end with Hyphen
  * min of 3 characters max of 63 characters
  * cannot be changed after creation
  * paid subscription can create more than one tenant
* Subscription tiers
  * Free - 1 tenant
  * Paid - more than 1 tenant (depends on subscription)

### Customise Tenant
* Recommended changes
  * Environment tag
  * Support email and support URL
  * Custom error page - provide CTA (Call to action)
  * Custom domain - reduce phishing; easier app management; brand loyalty. Requires credit card but not charged (just for fraud check)
  * SSO session timeout - 7 days by default; reduces attack surface
  * Tenant admins - enable MFA
  * Disable the 'Enable application connections setting' - if enabled all connections are available for any app you create (even if unintended)
  * Enable attack protection - suspicious IP throttling, bot detection, brute-force detection, breached passwords
  * External SMTP email provider - prod tenants require this (so do branding templates). Built in Auth0 email provider used for testing only (this dumb as it voids testing. Not like for like)

### Securing a tenant
* least privilege principle - only grant permissions to dashboards users that they need to do their job
* MFA for all admins: now mandatory for admins who use username/password or 3rd party social logins
* Periodically review
  * each user has legit reason for having access
  * members are registered with company email/account
  * former employees are toast
  * at least 2 admins per tenant
* Recovery (when dashboard access lost)
  * (LOL) use email account not tied to single user - access old users email and reset from their account (dumb idea)
  * Check for another admin on tenant - (you're fucked)

## Multi-Tenant Application Best Practices
* Auth0 recommends Auth0 Organisations (Groups of Users with tailed experiences) (this feels dumb for dev, test environments when you would most likely use a single tenant)
* Use cases
  * product licenced to another business
  * multiple orgs that need their own branding and auth experience
  * separate levels of access for different groups of users
* Legacy solutions
  * Challenge: if licencing to another business, how do you control licencing administration. Orgs only works if you 'own' administration
  * Auth0 connection, Auth0 application, Auth0 tenant (WHY? this is really good), storing tenant details in user's profile (Super dumb)
* Limits: 50 databases connections per application

## Validate Access Tokens
* JWT access tokens
  * use public certificates to validate signature
  * check expiry
  * check audience
  * verify permissions (scopes)
* Opaque tokens - Auth0 validates this when you send opaque token to Auth0

## Configure Refresh Token Rotation
* Refresh tokens are valid for a longer time making it easier to get multiple access tokens without having to reauthenticate the user
* Rotating (new): Every time a refresh token is used to get an access token, a refresh token is also returned (hence rotated)
* Auth0 will automatically swap out non rotating one for a rotating one (SDK will) when you change configuration to rotating
* Default: Auth0 SDK rotates if you use refresh tokens
* Default: if a token fails to validate then all tokens including refresh tokens are nuked

## Authorization Code and Access Token Variable Size Information
* Affects Auth0 opaque access tokens
* Major recent change
  * Previous Fixed Code length: 16 Chars 
  * New Behaviour: Currently, the Max is set to 45 Characters, but this is an implementation detail and can be changed.
* Auth0 Recommendation: not to rely on token size (this feels like a bad idea as it could result in DOS attacks)

## Token Best Practices
* Keep private signing keys safe – duh
* Don't add sensitive information to tokens
* Give tokens an expiry time
* Use HTTPS
* Store & reuse tokens
* Tokens vs cookies - if api and web app are on same domain just use cookies
* Refresh token usage
  * Flows - auth code flow, PKCE flow, Resource owner flow and device auth flow
  * offline access = no refresh token even if API request asks for it
  * rules will run for refresh token exchange (use context.protocol in custom rule, if equal to oauth2-refresh-token then rule is running during exchange)
  * audience parameter is not available on rules context object. You will get an error setting it if it already exists on token
  * if you try to redirect with with context.redirect the auth flow will return an error
  * if you added custom claims to token using rules, those claims will appear in new tokens issued by refresh token. Doesn't matter if refresh token is old or new
  * Limits: 200 'active' tokens per user per application. If limit reached, requesting a new refresh token will expire the oldest one first
  * Automated tests: will accumulate refresh tokens. Use the management API to delete them
  * https://auth0.com/docs/api/management/v2/device-credentials/get-device-credentials - can be used to get list of refresh tokens
  * https://auth0.com/docs/api/management/v2/device-credentials/delete-device-credentials-by-id - delete refresh token by id
  * Obsolete refresh tokens get created when a user logs in multiple times in a short period of time
  * Auth0 recommendation: Instead of manually deleteing refresh tokens just set **an expiry** time
* JWT Validation
  * Use middleware (JWT.io for validation SDK) - duh
  * Signing algorithms
    * RS256 - public apps
    * HS256 - confidential apps
    * Auth0 recommends RS256: one holder of private key; request token for multiple audiences; private key compromised just rotate key (no app redeployments required)
  * Signing Keys
    * multiple keys will be present in JWKS due to rotation of signing keys
    * cache these to improve performance, token validation failure shoudl result in cache invalidation (only one time) 

## Technical Strategies for Migrating Users to Auth0
### Features
* Import of Hashed user passwords available if they use a supported hash algorithm (https://auth0.com/docs/manage-users/user-migration/bulk-user-import-schema#supported-hash-algorithms)
* 
### Methods
* Bulk import of users - via management API or import/export extension
  * Reasons: urgency; deprecation of old system; old system obsolete, buggy, not compliant; old system licencing fees too expensive
  * Risks: may require multiple imports to capture all users; password hash may not be supported
  * Typical approach
  * Requires migration from exported schema to Auth0 schema (https://auth0.com/docs/manage-users/user-migration/bulk-user-import-schema)
  * Custom hash password can be provided in import schema to support hashed passwords
  * Features: can disable sign ups; require usernames instead of email
  * Requires management API scopes: create:users, read:connections
  * Flow (management API): call management API to import users; store returned id; wait for long running job to complete (use id to query progress);
  * Flow (import/export extension): install extension; upload JSON file; wait for long running job to complete
* Automatic (progressive) migration - via custom database connections (users are migrated only when they sign in)
  * Reasons: When its too hard to export data from existing system; great way to purge inactive users
  * Risks: not great if system has inactive/dormant users that you want to keep; password hash may not be supported; large time frame to migrate
  * When olds system is not immediately being deprecated
  * System must be available from the public internet (Auth0 can't access private systems)
  * How works: custom hooks written in javascript to call IdP API to get user details;
  * Flow: login in via Auth0; auth0 checks if user exists in Auth0; if so, login; if not call custom script to get user details from other IdP and store in Auth0
* Use your own user store
  * Reasons: Auth0 try before you by; forced to keep user store
  * Basically just migrate platform not data
  * Requires custom database
  * User store must be available from the public internet (Auth0 can't access private systems)
* Options
  * Automicate migration followed by bulk migration when you're ready to say goodbye to legacy IdP

### Precautions
* secure legacy public access - build a layer between world and legacy IdP
* import password hashes - to reduce friction
* enforce strong passwords - increase password lengths
* implement MFA

## User Migration Your Way
Knowledge from this section merged into previous section - nothing new

## Application Types
* Regular Web Applications
  * Backend
  * Authorisation Code Flow with PKCE recommended
  * Token storage: server side session or cookies
  * Session management: server side sessions with cookies
* Single Page Applications (SPA)
  * No backend
  * Authorisation Code Flow with PKCE recommended
  * Token storage: local/session storage
  * Session management: Token based sessions
* Native Applications (Mobile Apps)
  * No backend
  * Authorisation Code Flow with PKCE recommended
  * Token storage: secure storage (keychain, keystore)
  * Session management: Token based or local session management with cookies
* Machine to Machine Applications
  * Backend e.g. IoT, command line tool, daemon
  * Client Credentials Flow recommended
  * Token storage: secure server side
  * Session management: Stateless, uses tokens for authentication

### Tips
* Always have to add an 'API' if you want to use any apps
* Disable unnecessary grant types
* Use the principle of least privilege when assigning scopes
* Ensure secure token handling on client side (Validate signature, expiry etc)
* Follow Open ID Connect conformant settings (OIDC)

### SDKs
* Can be found in SDK libraries section - why this matters I have no idea
