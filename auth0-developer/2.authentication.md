# Authentication - Login

## Configure client application settings

### Application settings
* Advanced settings
  * manage/add application metadata tab
    * exposed as client_metadata for use in rules
    * max 255 characters
    * can have up to 10 sets of metadata
  * device settings tab
    * IOS - add team id and app id
    * Android - add package name & key hashes
  * OAuth tab
    * white list apps and apis
      * default: allow all (empty)
    * Compliance enforcement level
      * default: none
    * Non-Verifiable Callback URI End-User Confirmation - user has to login when callbcak is non verifiable
      * default: on
    * Algorithm used to sign JWTs - RS256
      * default: RS256
    * Trust Token endpoint IP header - auth0-forwarded-for is trusted as source of IP address and used to detect brute force attacks (Reg web apps and M2M only)
      * default: off
    * OIDC Compliant - will follow strictly
      * default: on
  * Grant types tab
  * WS Federation tab
  * Certificates tab
  * Endpoints tab

### Protocols
* OAuth 2.0
* OpenID Connect
* LDAP
* JWTs
* SAML
* SCIM (System ofr cross domain identity management)
* WS-Federation - microsoft only, dictates how security tokens can be exchanged

### Refresh tokens
* Compliance with: OAuth 2.0 Security BCP
* If expired token is used. All refresh tokens are invalidated and user must authenticate again
* New one issued when current refresh token is used. Old one is invalidated
  * Rotation Overlap Period - interval to allow leeway time that previous refresh token can still be used after new one is issued
* Recommends
  * automatic reuse detection
  * refresh token rotation
* SDK: supports refresh token management
* Affects flows
  * Authorization Code Flow (with/without PKCE)
  * Device Authorization Flow
  * Resource Owner Password Flow
* Lifetime settings
  * Idle
    * same as max but for when a user is not active in your application during a specified period of time
    * default: 30 days (2592,000 seconds)
    * min: 1 second
    * max: 1 year (31,557,600 seconds or 365.25 days)
    * cannot exceed max (see next)
  * max
    * after which a user must re-authenticate before being issued a new access token
    * disable then token expiry is indefinite (not applicable for browser based apps)
    * default: 1 year (31,557,600 seconds or 365.25 days) 
    * min: 1 second
    * max: 1 year (31,557,600 seconds or 365.25 days)
* Limitations
  * max determined at issuance and remains fixed during its lifetime even if max is updated
  * max can be overridden by [sessions with actions](https://auth0.com/docs/manage-users/sessions/manage-sessions-actions)
  * idle only updates with each successful refresh token exchange
  * max is changed, it will override any non-expiring refresh tokens with next exchange
  * once non-expiring refresh token is converted to expiring it cannot be reverted back again
    
## Set up single sign-on (SSO)
* Provided via an SSO Cookie representing a session for each of the following domains (if used)
  * application - managed by 'your' application typically via SDK
  * auth server - makes SSO possible
  * IdP (social or 3rd party)
* Any issued signed tokens by one domain will be accepted by any other domain
* Availability: only via Universal login
* SDK: use checkSession to silently login using SSO (does via an iframe to allow access to Auth0 cookie)
* Protocol support: SAML, WS-Federation, OpenID Connect, AD/LDAP
* Service-provider-initiated SSO: Auth0 is SSO service provider and redirects to IdP to authenticate
* Identity-provider-initiated SSO: 3rd party IdP is SSO identity provider. Use SSO Dashboard Extension can provide multiple enterprise apps that can be enabled for SSO

## Set up single logout functionality

### Log users out of applications / IdPs
* Cookies
  * Application cookie - killing this session doesn't kill your session with Auth0 unless you use logout endpoints
  * Auth0 cookie - killing this session kills your session with Auth0 via /logout endpoint
    * You should kill your app session first before calling /logout
  * IdP cookie - Remains active even logged out at app and auth0 server layers
    * Normally leaving this is good in the case of Google users. But in enterprise, federated logout fixies this
    * Good practice - alert users that they are logging out of 3rd party IdPs
* How to check if a session is valid (best to manage via Auth0 SDK)
  * Silently login (not recommended)
    * SPA
  * 302 redirect to /authorise
    * Regular web app
  * Use refresh tokens
    * Regular web app
    * SPA (PKCE)
* All log outs: log you out of Auth0 and optionally your IdP but not your (client side) application you must do this yourself
* (Old or Alternative) Proprietary endpoint (/v2/logout or /v2/logout?federated for 3rd party IdPs also)
  * uses returnTo query parameter and if this is left empty, it redirects to an empty 200 response
  * has **NO** logout or id token hints to provide assurance of the legitimacy of the logout request
  * does **NOT** provide endpoint discovery option
  * Only supports GET
  * no validation perform on returnTo query parameter
  * federated logout with social providers is inconsistent. Some will use returnTo and some will not
  * Google/Facebook - you must set clientId and secret for these providers in dashboard for logout to work correctly
  * Redirect - Must be added to Allowed Logout URLs at application level or tenant level when no client_id provided
* (New) OIDC Logout - RP-initiated endpoint (Relaying party - service or application, /oidc/logout or /oidc/logout?federated for 3rd party IdPs also)
  * uses post_logout_redirect_uri query parameter and if this is left empty, it redirects users to a generic Auth0 landing page
  * uses id_token_hint or logout_hint, which provide assurance of the legitimacy of the logout request
  * OIDC logout offers extended validation by parsing and validating query parameters in the post_logout_redirect_uri
  * Endpoint Discovery: The OIDC logout endpoint can be discovered through the tenant’s .well-known public resource, 
    facilitating easier integration and standard compliance (has to be enabled 
    Dashboard > Settings > Advanced > Login & Logout > RP-Initiated Logout End Session Endpoint Discovery)
  * Supports GET & POST
  * Optionally uses the client_id to validate the post-logout URL listed in the Allowed Logout URLs. If the client_id or 
    id_token_hint is missing, it falls back to the tenant's allowed list
  * Works in **ONE** of two ways:
    * invalidates SSO cookie **OR**
    * Signs users out of IdPs (IdP, such as ADFS or Google)
  * Only signs you out of the current application immediately
    * Why: because invalidating an SSO cookie only logs you out if you attempt to authenticate with it (i.e. silently) 
    * If you need to be signed out of all applications immediately
      * OIDC Back Channel Logout - (MORE SECURE). See below for details. All done outside of browser  
      * OIDC Front channel logout - (LESS SECURE - can be intercepted via browser) handle this at the (client side) 
        application level by providing a way to notify all other applications when a logout occurs
      * OIDC Session Management - have shorter timeouts on local sessions via checkSession so silently authenticate with now invalidated SSO cookie
      * SAML Single Logout (SLO)
  * Redirect
    * Must be added to Allowed Logout URLs
      * Application settings: If you provide the id_token_hint parameter, or the logout_hint and client_id parameters (you provide these in you actual app call)
      * Tenant settings: If you provide only the logout_hint parameter
* Redirect URLs (Common to both)
  * For use with application - returnTo (old) or post_logout_redirect_uri (new) query parameter must be encoded
  * In Allowed callback URLs field - returnTo (old) or post_logout_redirect_uri (new) query parameter must be un-encoded (comma separated, * for subdomains, and case-sensitive)
  * if client_id is **NOT** provided, then you must set post logout URL in allowed logout at tenant level
  * wildcards for subdomains are supported but not recommended for production

### OIDC Back Channel Logout
* Supported in express-openid-connect SDK
* enterprise subscription only
* If you logout of one app, auth0 can logout other applications via registered backchannel urls
* Applications cannot rely on session cookies to determine which session to terminate when comms are done via back channel
  Rather the service depends on a shared session identifier ( sid ) from ID and Logout tokens
* Logout tokens are generated by Auth0 when a session is destroyed via /logout or session revocation
* Apps must register a back channel callback URL for this to work so Auth0 knows what apps to call when logout occurs
* If one app logs out with Auth0 then Auth0 will log out of all other registered apps via callbacks
* Flow
  1. Login - During user authentication with apps, the Auth0 tenant provides ID token with with sid and uid (session id and user id)
  2. Login - App stores the received session identifier in its own session store and associates it with the application-specific session
  3. Logout - Auth0 calls the pre-registered logout callback URL and posts the Logout Token to this endpoint. 
     The token contains the uid and the sid along with other parameters
  4. Logout - The application’s backend needs to validate the Logout Token as per OIDC spec and extract the sid. Then the 
     backend can use this token to find the session associated with the identifier and terminate it as necessary
* Limitations
  * Apps must be able to store sid
  * Apps can verify JWT tokens
  * Apps only accept tokens by trusted tenants
  * Apps must only accept tokens with sid
  * Apps must expose callback endpoints only via TLS
  * Apps recommended to only accept requests from published list of outbound IP addresses
  * Apps provide rate limiting
  * Any changes to endpoint address must be synce with Auth0 tenant

## Configure cross-origin authentication
* Configured as Application > Allowed origins (CORS)
* Workaround: When 3rd party cookies are blocked, SDK > corssOriginVerificiation set to dedicated page with non cross origin domain
* Custom domains - Most browsers do not support cross origin authentication unless you use an Auth0 tenant custom domain
  * Require setting of CNAME on DNS provider

### Hosted (Universal Login) vs Embedded login
* You choose either Universal Login OR Embedded Login
* Cross origin: Embedded uses cross-origin authentication unless you configure a custom domain in Auth0 tenant
* Key differences between Universal Login and Embedded Login
  * SSO: Hosted - full support; Embedded - Limited have to use Lock or Auth0.js libraries to share session with apps OR 'Native to Web sso' for Native apps
  * Customisation: Hosted - Almost full; Embedded - highest degree of customisation
  * Feature management: Hosted - immediate change via dashboard; Embedded - need to do new release
  * User experience: Hosted - users redirected between app and Auth0; Embedded - users stay in app
  * Security and maintenance: Hosted - outsourced to Auth0; Embedded - Up to you
  * Effort: Hosted - low; Embedded - high
* Lock for Web / Custom UI
  * Only works with Classic login
  * Widget to provide embedded login experience
  * Custom signup
    * Lock sends custom fields to e /dbconnections/signup (behind scenes). Stored in user_metadata
    * User metadata
      * can have more than username and password - you could capture meta data to store against a user
      * Database signups - additionalSignUpFields attribute can collect users meta data on sign up
      * IDP signups - redirect to another page (one off) or progressive profiling (collect data over time)
      * Limitations
        * 10 fields max
        * must be a string
        * Field name - max 100 characters
        * Field value - max 500 characters
        * Total user_metadata is 16MB
    * Redirect mode - after signup, Auth0 will redirect to callback URL with id_token as query parameter
    * Can add username
    * Can set password strength policies in dashboard - database connections only (retrieved from management API)

## Set up authentication profile (How you login)
* WebAuthN only available in Universal Login
* If using custom database make sure 'Import Mode' for connection is 'on'. If not, you'll have to use getUser script
* Identifier + password - user enters email address and password
* Identifier first - user enters email and is prompted for password on another screen
* Identifier + Biometerics - when possible users have ability to choose WebAuthN  method instead of password
* Enable home realm discovery
  * Not available for Identifier + password
  * When email provided user is forwarded to IdP for authentication
  * Configured in Dashboard > Authentication > Enterprise
* MFA
  * If MFA enabled, not used if users passed WebAuthN check as first factor
  * If MFA enabled, users are still expected to register for MFA even if they have WebAuthN with biometrics configured
    * You can get around this with a rule that checks authMethods for 'webauthn-platform' to be set and then bypass MFA
* Biometrics
  * 'Known Device' - if user logs in with windows hello on one device, Auth0 stores a 'known device', so they will not have to provide their password next time
    * This does not work across browsers as Auth0 stores this information in cookie
  * Requires Javascript to be enabled on browser
* Relaying Party ID feature with WebAuthN
  * If you need to set a custom domain, do so before rolling out WebAuthn in production environments. 
    If you set or change a custom domain, previously enrolled users will not be able to authenticate. You can use the Relying 
    Party setting to specify the domain used to authenticate users
  * Only available with Custom Domain. If custom domain changes, you must change the Relay party ID
  * Makes phishing impossible by binding user creds with domain
  * Is set to any domain or subdomain of the tenant domain
* Device Recognition
  * Windows/IOS - WebAuthN done at OS level. User can use any browser to authenticate
  * MacOS - WebAuthN done at browser level. Users will need to register when using different browsers
  * Android - WebAuthN done at OS level. User can use any browser to authenticate (only webkit browsers supported)
* Device support
  * use must have another MFA enrollment activated before using device biometrics
  * WebAuthN can never be used a second factor. Always progressive enrollment prompt
  * MFA API can list and remove WebAuthN enrollments but cannot enroll them
  * Users can only enroll one device per type using WebAuthN with biometrics (one phone, one tablet, one desktop). 2nd 
    device of same type will require unenrollment of first device
* Passwordless Authentication with SMS
  * Sends OTP to device
  * Supports 
    * Twilio
    * Custom implementation (via actions) to send SMS 
    * your own implementation that uses Auth0's Management API (legacy SMS providers)
  * Embedded - only difference is App acts as proxy for SMS number
  * Configuration (settings)
    * Message body - uses liquid syntax
    * Multi-language support
    * Can set for specific applications

## Understand and Implement Authentication APIs - covered by other sections

## Implement JWT token validation using JWKS
### High level JWT structure
* JOSE (JSON Object Signing and Encryption) Header - contains algorithm used to sign JWT
* JWS Payload - contains claims about the JWT
* JWS signature - used to verify the JWT

### How to verify tokens
* Verify standard claims
  * Audience (aud) - must match clientID
  * Issuer (iss) - must match Auth0 tenant domain
  * Expiry (exp) - must be in the future
  * Issued at (iat) - must be in the past
* Verify custom claims
  * Custom claims can be added to JWTs issued by Auth0
* Verify Header
  * Algorithm (alg) - must match algorithm used to sign JWT
* Verify Signature
  * Auth0 uses RSA-SHA256 to sign tokens
  * Use JWKS endpoint to get public keys for verification to reduce maintenance burden

### ID Tokens
* aud - set to clientID
* amr - authentication methods used e.g. mfa,sms,pwd
* sub - subject identifier
* iss - issuer identifier
* typ (in header) - used to authenticate (contains user information)
* alg (in header) - algorithm used to sign JWT

### Access Tokens
* aud - set to API identifier
* type - used to authorise
  * Opaque - used to get scopes from Auth0 (good if you have lots of scopes, bad because extra API call)
  * JWT - scope included in Access token (good if you want fewer API calls, bad if you have lots of scopes - there are JWT limits)

### Specialised Tokens
* Refresh Tokens: used to obtain new access tokens
* IDP access Tokens: used to obtain new access tokens from IdP
* Auth0 Management API Access Tokens: used to access Auth0 Management API

# Authentication - Provisioning users

## Configure identity providers
* Supported providers:
  * Active Directory/LDAP
  * ADFS
  * Azure Active Directory Native
  * Google Workspace
  * OpenID Connect
  * Okta
  * PingFederate
  * SAML
  * Azure Active Directory
* OIDC support - Enterprise connections that support this can: perform PKCE; attribute claims and access token mapping; Userinfo integration
* VERY IMPORTANT - Some social connections you can leave client id and secret blank to get Auth0 to use its own dev keys i.e. for Github (For prod you'd get your own keys)
* Flow
  * Create connection
  * Select which applications can use it
  * Test it
* First time use of social connection will result in authorisation prompt between IdP and Auth0 (or customised name) - the trust workflow
  * This works if Social connection provider is OIDC compliant
* Normalise a profile - just Auth0 mapping OIDC user profile to a common profile in Auth0 for that user for consistence exchanges with Auth0
* B2C
  * social connections, password, passwordless
  * auth0 provides developer keys for non-prod environments
  * identity lifecycle is managed by the external social IdP or Auth0 if password/passwordless
* B2E - enterprise connections
  * Limitations - Auth0 cannot provision, update or delete users
  * you must provide developer keys for all environments
  * identity lifecycle is managed by the external enterprise IdP
* B2B - closed enterprise connections whereby you can invite business partners to join your tenant (organisations)
  * identity lifecycle is managed by the external enterprise IdP - registration, email verificaiton, etc...
  * you must provide developer keys for all environments

## Set up Connections
* 4 types
  * Database (Password) (B2C)
    * Lifecycle Ownership: Auth0 (You)
    * User source: Auth0 or custom database
      * Supports Passkeys (Type of passwordless but with database only)
        * Progressive rollout (optional). Users can delay by 30 days
        * Local enrollment (optional) - means they need to create a new key per device instead of using cross-device key
        * Does not replace or invalidate username and password
        * Options:
          * Autofill - users must login with browser autofill function to select saved account from dropdown list when engaging with prompt 
          * Passkey button - Users select 'Continue with Passkey' button on prompt
          * Both - Autofill and Passkey button
        * Enrollment: via Passkey QR code scanner
        * Prerequisites:
          * Enable Identifier first login flow
          * Disable custom login page
          * Disable requires username option
          * Disable use my own database unless import users to Auth0 is enabled
          * Enable Universal login
        * Post login action to skip MFA when using Passkey
          ```javascript
          /**
           * Handler that will be called during the execution of a PostLogin flow.
           *
           * @param {Event} event - Details about the user and the context in which they are logging in.
           * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.
           */
          exports.onExecutePostLogin = async (event, api) => {
            // Check if a passkey was used to authenticate
            const skipMFA = event.authentication?.methods.some(
                    (method) => method.name === "passkey"
            );
        
            // If a passkey was used skip MFA
            if (skipMFA) {
              api.multifactor.enable("none");
            }
          };
          ```
          * Benefits: control password policy 
            * Length, complexity
            * History - remembers up to last 24 passwords
            * Dictionary - can restrict users from using dumb passwords using an Auth0 password dictionary plus custom entries
            * Disallow personal data - can restrict users from using data from their profile
  * Passwordless (B2C) - Just SMS and Email only 
    * Lifecycle Ownership: Auth0 (You) - auth0 verifies credentials
    * User source: Auth0
    * Benefits: phishing resistant, user signup can be disabled, no passwords required
    * Supports: SMS and/or email
    * Flow:
      * User enters email address or phone number
      * Auth0 sends OTP to user vis SMS or email
      * User enters OTP to continue
    * Limitations
      * Doesn't support the ability to connect to an external user store
  * Enterprise (B2E, B2B)
    * Lifecycle Ownership: external IdP
    * User source: external IdP
  * Social (B2C)
    * Lifecycle Ownership: external IdP
    * User source: external IdP

## Integrate with LDAP or Active Directory
* LDAP requires special treatment
  * Auth0 AD/LDAP Connector
    * must install Auth0 AD/LDAP Connector on your network (there is a extension for this that can monitor access)
    * must map AD/LDAP profile attributes to Auth0 user profile attributes using 'Profile Mapper' @ http://localhost:8357

## Implement appropriate database strategies

### Automatic (Progressive, lazy, trickle) Migration
* Use case: Filter out inactive users
* Often good to combine by finishing with Bulk import when ready to migrate (for longer timeframe, legacy system must 
  remain online longer and may receive updates leading to inconsistency)
* Import users when they login to Auth0 for the first time -set 'import users to Auth0' flag to on
* Still requires ACTION scripts to perform data actions (see Legacy Database section below)
  * Only requires Login & Get User (during sign ups, password changes or multi factor auth setup) scripts though

### Legacy Database (Connect tool, Use Action scripts)
* Use case: Compliance requirements; just exploring (POC); 
* Can only be used with a database connection that current has 'NO' users
* Do not import users when they login to Auth0 but instead cache data - set 'import users to Auth0' flag to off
* Action scripts
  * Uses 'ACTION' scripts to perform the following data actions:
    * Change Password
    * Create User
    * Delete User
    * Get User
    * Login
    * Verify User
    * Change Email
  * Supports multiple languages - Postgres, Javascript, MongoDB, MySQL, SQL Server
  * Limitations
    * Async Support - but limited to max 20 seconds execution time. Exceeding this time will cause the action to fail 
      and potential reset of global user object
  * Completion
    * use callback method provided and call 'ONLY' once - otherwise unpredictable results may follow
    * running callback() gets resolved to callback(null)

### Bulk user import (bulk import)
* Use case: Deprecated system; urgency
* Often good to combine with Automatic migration to capture any missing users from bulk import
* Supports password hashes (limited to particular algorithms)
  * Used only first time a user logs in to Auth0. After that its rehashed using Auth0's default algorithm bcrypt
* Support
  * management API (Recommended, more reliable, more flexible because more functionality)
  * Auth0 Dashboard