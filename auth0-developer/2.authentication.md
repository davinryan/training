# Authentication - Login

## Configure client application settings

### Application settings
* Advanced settings
  * manage/add application metadata tab
    * exposed as client_metadata for use in rules
    * max 255 characters
    * can have up to 10 sets of metadata
  * device settings tab
    * IOS - add team id and app id
    * Android - add package name & key hashes
  * OAuth tab
    * white list apps and apis
      * default: allow all (empty)
    * Compliance enforcement level
      * default: none
    * Non-Verifiable Callback URI End-User Confirmation - user has to login when callbcak is non verifiable
      * default: on
    * Algorithm used to sign JWTs - RS256
      * default: RS256
    * Trust Token endpoint IP header - auth0-forwarded-for is trusted as source of IP address and used to detect brute force attacks (Reg web apps and M2M only)
      * default: off
    * OIDC Compliant - will follow strictly
      * default: on
  * Grant types tab
  * WS Federation tab
  * Certificates tab
  * Endpoints tab

### Protocols
* OAuth 2.0
* OpenID Connect
* LDAP
* JWTs
* SAML
* SCIM (System ofr cross domain identity management)
* WS-Federation - microsoft only, dictates how security tokens can be exchanged

### Refresh tokens
* Compliance with: OAuth 2.0 Security BCP
* New one issued when current refresh token is used. Old one is invalidated
  * Rotation Overlap Period - interval to allow leeway time that previous refresh token can still be used after new one is issued
* Recommends
  * automatic reuse detection
  * refresh token rotation
* SDK: supports refresh token management
* Affects flows
  * Authorization Code Flow (with/without PKCE)
  * Device Authorization Flow
  * Resource Owner Password Flow
* Lifetime settings
  * Idle
    * same as max but for when a user is not active in your application during a specified period of time
    * default: 30 days (2592,000 seconds)
    * min: 1 second
    * max: 1 year (31,557,600 seconds or 365.25 days)
    * cannot exceed max (see next)
  * max
    * after which a user must re-authenticate before being issued a new access token
    * disable then token expiry is indefinite (not applicable for browser based apps)
    * default: 1 year (31,557,600 seconds or 365.25 days) 
    * min: 1 second
    * max: 1 year (31,557,600 seconds or 365.25 days)
* Limitations
  * max determined at issuance and remains fixed during its lifetime even if max is updated
  * max can be overridden by [sessions with actions](https://auth0.com/docs/manage-users/sessions/manage-sessions-actions)
  * idle only updates with each successful refresh token exchange
  * max is changed, it will override any non-expiring refresh tokens with next exchange
  * once non-expiring refresh token is converted to expiring it cannot be reverted back again
    
## Set up single sign-on (SSO)
* Provided via an SSO Cookie representing a session for each of the following domains (if used)
  * application
  * auth server
  * IdP (social or 3rd party)
* Any issued signed tokens by one domain will be accepted by any other domain
* Availability: only via Universal login
* SDK: use checkSession to silently login using SSO (does via an iframe to allow access to Auth0 cookie)
* Protocol support: SAML, WS-Federation, OpenID Connect, AD/LDAP
* Service-provider-initiated SSO: Auth0 is SSO service provider and redirects to IdP to authenticate
* Identity-provider-initiated SSO: 3rd party IdP is SSO identity provider. Use SSO Dashboard Extension can provide multiple enterprise apps that can be enabled for SSO

## Set up single logout functionality

### Log users out of applications / IdPs
* All log outs: log you out of Auth0 and optionally your IdP but not your (client side) application you must do this yourself
* (Old or Alternative) Proprietary endpoint (/v2/logout or /v2/logout?federated for 3rd party IdPs also)
  * uses returnTo query parameter and if this is left empty, it redirects to an empty 200 response
  * has **NO** logout or id token hints to provide assurance of the legitimacy of the logout request
  * does **NOT** provide endpoint discovery option
  * Only supports GET
  * no validation perform on returnTo query parameter
  * federated logout with social providers is inconsistent. Some will use returnTo and some will not
  * Google/Facebook - you must set clientId and secret for these providers in dashboard for logout to work correctly
  * Redirect - Must be added to Allowed Logout URLs at application level or tenant level when no client_id provided
* (New) OIDC Logout - RP-initiated endpoint (Relaying party - service or application, /oidc/logout or /oidc/logout?federated for 3rd party IdPs also)
  * uses post_logout_redirect_uri query parameter and if this is left empty, it redirects users to a generic Auth0 landing page
  * uses id_token_hint or logout_hint, which provide assurance of the legitimacy of the logout request
  * OIDC logout offers extended validation by parsing and validating query parameters in the post_logout_redirect_uri
  * Endpoint Discovery: The OIDC logout endpoint can be discovered through the tenant’s .well-known public resource, 
    facilitating easier integration and standard compliance (has to be enabled 
    Dashboard > Settings > Advanced > Login & Logout > RP-Initiated Logout End Session Endpoint Discovery)
  * Supports GET & POST
  * Optionally uses the client_id to validate the post-logout URL listed in the Allowed Logout URLs. If the client_id or 
    id_token_hint is missing, it falls back to the tenant's allowed list
  * Works in **ONE** of two ways:
    * invalidates SSO cookie **OR**
    * Signs users out of IdPs (IdP, such as ADFS or Google)
  * Only signs you out of the current application immediately
    * Why: because invalidating an SSO cookie only logs you out if you attempt to authenticate with it (i.e. silently) 
    * If you need to be signed out of all applications immediately
      * handle this at the (client side) application level by providing a way to notify all other applications when a logout occurs
      * have shorter timeouts on local sessions via checkSession so silently authenticate with now invalidated SSO cookie
  * Redirect
    * Must be added to Allowed Logout URLs
      * Application settings: If you provide the id_token_hint parameter, or the logout_hint and client_id parameters (you provide these in you actual app call)
      * Tenant settings: If you provide only the logout_hint parameter
* Redirect URLs (Common to both)
  * For use with application - returnTo (old) or post_logout_redirect_uri (new) query parameter must be encoded
  * In Allowed callback URLs field - returnTo (old) or post_logout_redirect_uri (new) query parameter must be un-encoded (comma separated, * for subdomains, and case-sensitive)
  * if client_id is **NOT** provided, then you must set post logout URL in allowed logout at tenant level
  * wildcards for subdomains are supported but not recommended for production

### OIDC Back Channel Logout
* If you logout of one app, auth0 can logout other applications via registered backchannel urls
* Applications cannot rely on session cookies to determine which session to terminate when comms are done via back channel
  Rather the service depends on a shared session identifier ( sid ) from ID and Logout tokens
* Logout tokens are generated by Auth0 when a session is destroyed via /logout or session revocation
* Apps must register a back channel callback URL for this to work so Auth0 knows what apps to call when logout occurs
* If one app logs out with Auth0 then Auth0 will log out of all other registered apps via callbacks
* Flow
  1. Login - During user authentication with apps, the Auth0 tenant provides ID token with with sid and uid (session id and user id)
  2. Login - App stores the received session identifier in its own session store and associates it with the application-specific session
  3. Logout - Auth0 calls the pre-registered logout callback URL and posts the Logout Token to this endpoint. 
     The token contains the uid and the sid along with other parameters
  4. Logout - The application’s backend needs to validate the Logout Token as per OIDC spec and extract the sid. Then the 
     backend can use this token to find the session associated with the identifier and terminate it as necessary
* Limitations
  * Apps must be able to store sid
  * Apps can verify JWT tokens
  * Apps only accept tokens by trusted tenants
  * Apps must only accept tokens with sid
  * Apps must expose callback endpoints only via TLS
  * Apps recommended to only accept requests from published list of outbound IP addresses
  * Apps provide rate limiting
  * Any changes to endpoint address must be synce with Auth0 tenant

## Configure cross-origin authentication
* Configured as Application > Allowed origins (CORS)
* Workaround: When 3rd party cookies are blocked, SDK > corssOriginVerificiation set to dedicated page with non cross origin domain
* Custom domains - Most browsers do not support cross origin authentication unless you use an Auth0 tenant custom domain
  * Require setting of CNAME on DNS provider

### Hosted (Universal Login) vs Embedded login
* You choose either Universal Login OR Embedded Login
* Cross origin: Embedded uses cross-origin authentication unless you configure a custom domain in Auth0 tenant
* Key differences between Universal Login and Embedded Login
  * SSO: Hosted - full support; Embedded - Limited have to use Lock or Auth0.js libraries to share session with apps OR 'Native to Web sso' for Native apps
  * Customisation: Hosted - Almost full; Embedded - highest degree of customisation
  * Feature management: Hosted - immediate change via dashboard; Embedded - need to do new release
  * User experience: Hosted - users redirected between app and Auth0; Embedded - users stay in app
  * Security and maintenance: Hosted - outsourced to Auth0; Embedded - Up to you
  * Effort: Hosted - low; Embedded - high
* Lock for Web / Custom UI
  * Only works with Classic login
  * Widget to provide embedded login experience
  * Custom signup
    * Lock sends custom fields to e /dbconnections/signup (behind scenes). Stored in user_metadata
    * User metadata
      * can have more than username and password - you could capture meta data to store against a user
      * Database signups - additionalSignUpFields attribute can collect users meta data on sign up
      * IDP signups - redirect to another page (one off) or progressive profiling (collect data over time)
      * Limitations
        * 10 fields max
        * must be a string
        * Field name - max 100 characters
        * Field value - max 500 characters
        * Total user_metadata is 16MB
    * Redirect mode - after signup, Auth0 will redirect to callback URL with id_token as query parameter
    * Can add username
    * Can set password strength policies in dashboard - database connections only (retrieved from management API)

## Set up authentication profile (How you login)
* WebAuthN only available in Universal Login
* If using custom database make sure 'Import Mode' for connection is 'on'. If not, you'll have to use getUser script
* Identifier + password - user enters email address and password
* Identifier first - user enters email and is prompted for password on another screen
* Identifier + Biometerics - when possible users have ability to choose WebAuthN  method instead of password
* Enable home realm discovery
  * Not available for Identifier + password
  * When email provided user is forwarded to IdP for authentication
  * Configured in Dashboard > Authentication > Enterprise
* MFA
  * If MFA enabled, not used if users passed WebAuthN check as first factor
  * If MFA enabled, users are still expected to register for MFA even if they have WebAuthN with biometrics configured
    * You can get around this with a rule that checks authMethods for 'webauthn-platform' to be set and then bypass MFA
* Biometrics
  * 'Known Device' - if user logs in with windows hello on one device, Auth0 stores a 'known device', so they will not have to provide their password next time
    * This does not work across browsers as Auth0 stores this information in cookie
  * Requires Javascript to be enabled on browser
* Relaying Party ID feature with WebAuthN
  * If you need to set a custom domain, do so before rolling out WebAuthn in production environments. 
    If you set or change a custom domain, previously enrolled users will not be able to authenticate. You can use the Relying 
    Party setting to specify the domain used to authenticate users
  * Only available with Custom Domain. If custom domain changes, you must change the Relay party ID
  * Makes phishing impossible by binding user creds with domain
  * Is set to any domain or subdomain of the tenant domain
* Device Recognition
  * Windows/IOS - WebAuthN done at OS level. User can use any browser to authenticate
  * MacOS - WebAuthN done at browser level. Users will need to register when using different browsers
  * Android - WebAuthN done at OS level. User can use any browser to authenticate (only webkit browsers supported)
* Device support
  * use must have another MFA enrollment activated before using device biometrics
  * WebAuthN can never be used a second factor. Always progressive enrollment prompt
  * MFA API can list and remove WebAuthN enrollments but cannot enroll them
  * Users can only enroll one device per type using WebAuthN with biometrics (one phone, one tablet, one desktop). 2nd 
    device of same type will require unenrollment of first device
* Passwordless Authentication with SMS
  * Sends OTP to device
  * Supports 
    * Twilio
    * Custom implementation (via actions) to send SMS 
    * your own implementation that uses Auth0's Management API (legacy SMS providers)
  * Embedded - only difference is App acts as proxy for SMS number
  * Configuration (settings)
    * Message body - uses liquid syntax
    * Multi-language support
    * Can set for specific applications

## Understand and Implement Authentication APIs - covered by other sections

## Implement JWT token validation using JWKS
### JWT structure
* JOSE (JSON Object Signing and Encryption) Header - contains algorithm used to sign JWT
* JWS Payload - contains claims about the JWT
* JWS signature - used to verify the JWT

### ID Tokens
* aud - set to clientID
* type - used to authenticate (contains user information)

### Access Tokens
* aud - set to API identifier
* type - used to authorise
  * Opaque - used to get scopes from Auth0 (good if you have lots of scopes, bad because extra API call)
  * JWT - scope included in Access token (good if you want fewer API calls, bad if you have lots of scopes - there are JWT limits)

### Specialised Tokens
* Refresh Tokens: used to obtain new access tokens
* IDP access Tokens: used to obtain new access tokens from IdP
* Auth0 Management API Access Tokens: used to access Auth0 Management API

# Authentication - Provisioning users