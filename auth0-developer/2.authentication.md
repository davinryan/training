# Authentication - Login

## Configure client application settings

### Application settings
* Advanced settings
  * manage/add application metadata tab
    * exposed as client_metadata for use in rules
    * max 255 characters
    * can have up to 10 sets of metadata
  * device settings tab
    * IOS - add team id and app id
    * Android - add package name & key hashes
  * OAuth tab
    * white list apps and apis
      * default: allow all (empty)
    * Compliance enforcement level
      * default: none
    * Non-Verifiable Callback URI End-User Confirmation - user has to login when callbcak is non verifiable
      * default: on
    * Algorithm used to sign JWTs - RS256
      * default: RS256
    * Trust Token endpoint IP header - auth0-forwarded-for is trusted as source of IP address and used to detect brute force attacks (Reg web apps and M2M only)
      * default: off
    * OIDC Compliant - will follow strictly
      * default: on
  * Grant types tab
  * WS Federation tab
  * Certificates tab
  * Endpoints tab

### Protocols
* OAuth 2.0
* OpenID Connect
* LDAP
* JWTs
* SAML
* SCIM (System ofr cross domain identity management)
* WS-Federation - microsoft only, dictates how security tokens can be exchanged

### Refresh tokens
* Compliance with: OAuth 2.0 Security BCP
* New one issued when current refresh token is used. Old one is invalidated
  * Rotation Overlap Period - interval to allow leeway time that previous refresh token can still be used after new one is issued
* Recommends
  * automatic reuse detection
  * refresh token rotation
* SDK: supports refresh token management
* Affects flows
  * Authorization Code Flow (with/without PKCE)
  * Device Authorization Flow
  * Resource Owner Password Flow
* Lifetime settings
  * Idle
    * same as max but for when a user is not active in your application during a specified period of time
    * default: 30 days (2592,000 seconds)
    * min: 1 second
    * max: 1 year (31,557,600 seconds or 365.25 days)
    * cannot exceed max (see next)
  * max
    * after which a user must re-authenticate before being issued a new access token
    * disable then token expiry is indefinite (not applicable for browser based apps)
    * default: 1 year (31,557,600 seconds or 365.25 days) 
    * min: 1 second
    * max: 1 year (31,557,600 seconds or 365.25 days)
* Limitations
  * max determined at issuance and remains fixed during its lifetime even if max is updated
  * max can be overridden by [sessions with actions](https://auth0.com/docs/manage-users/sessions/manage-sessions-actions)
  * idle only updates with each successful refresh token exchange
  * max is changed, it will override any non-expiring refresh tokens with next exchange
  * once non-expiring refresh token is converted to expiring it cannot be reverted back again
    
## Set up single sign-on (SSO)
* Provided via an SSO Cookie representing a session for each of the following domains (if used)
  * application
  * auth server
  * IdP (social or 3rd party)
* Any issued signed tokens by one domain will be accepted by any other domain
* Availability: only via Universal login
* SDK: use checkSession to silently login using SSO (does via an iframe to allow access to Auth0 cookie)
* Protocol support: SAML, WS-Federation, OpenID Connect, AD/LDAP
* Service-provider-initiated SSO: Auth0 is SSO service provider and redirects to IdP to authenticate
* Identity-provider-initiated SSO: 3rd party IdP is SSO identity provider. Use SSO Dashboard Extension can provide multiple enterprise apps that can be enabled for SSO

## Set up single logout functionality

### Log users out of applications / IdPs
* All log outs: log you out of Auth0 and optionally your IdP but not your (client side) application you must do this yourself
* (Old or Alternative) Proprietary endpoint (/v2/logout or /v2/logout?federated for 3rd party IdPs also)
  * uses returnTo query parameter and if this is left empty, it redirects to an empty 200 response
  * has **NO** logout or id token hints to provide assurance of the legitimacy of the logout request
  * does **NOT** provide endpoint discovery option
  * Only supports GET
  * no validation perform on returnTo query parameter
  * federated logout with social providers is inconsistent. Some will use returnTo and some will not
  * Google/Facebook - you must set clientId and secret for these providers in dashboard for logout to work correctly
  * Redirect - Must be added to Allowed Logout URLs at application level or tenant level when no client_id provided
* (New) OIDC Logout - RP-initiated endpoint (Relaying party - service or application, /oidc/logout or /oidc/logout?federated for 3rd party IdPs also)
  * uses post_logout_redirect_uri query parameter and if this is left empty, it redirects users to a generic Auth0 landing page
  * uses id_token_hint or logout_hint, which provide assurance of the legitimacy of the logout request
  * OIDC logout offers extended validation by parsing and validating query parameters in the post_logout_redirect_uri
  * Endpoint Discovery: The OIDC logout endpoint can be discovered through the tenant’s .well-known public resource, 
    facilitating easier integration and standard compliance (has to be enabled 
    Dashboard > Settings > Advanced > Login & Logout > RP-Initiated Logout End Session Endpoint Discovery)
  * Supports GET & POST
  * Optionally uses the client_id to validate the post-logout URL listed in the Allowed Logout URLs. If the client_id or 
    id_token_hint is missing, it falls back to the tenant's allowed list
  * Works in **ONE** of two ways:
    * invalidates SSO cookie **OR**
    * Signs users out of IdPs (IdP, such as ADFS or Google)
  * Only signs you out of the current application immediately
    * Why: because invalidating an SSO cookie only logs you out if you attempt to authenticate with it (i.e. silently) 
    * If you need to be signed out of all applications immediately
      * handle this at the (client side) application level by providing a way to notify all other applications when a logout occurs
      * have shorter timeouts on local sessions via checkSession so silently authenticate with now invalidated SSO cookie
  * Redirect
    * Must be added to Allowed Logout URLs
      * Application settings: If you provide the id_token_hint parameter, or the logout_hint and client_id parameters (you provide these in you actual app call)
      * Tenant settings: If you provide only the logout_hint parameter
* Redirect URLs (Common to both)
  * For use with application - returnTo (old) or post_logout_redirect_uri (new) query parameter must be encoded
  * In Allowed callback URLs field - returnTo (old) or post_logout_redirect_uri (new) query parameter must be un-encoded (comma separated, * for subdomains, and case-sensitive)
  * if client_id is **NOT** provided, then you must set post logout URL in allowed logout at tenant level
  * wildcards for subdomains are supported but not recommended for production

### OIDC Back Channel Logout
* If you logout of one app, auth0 can logout other applications via registered backchannel urls
* Applications cannot rely on session cookies to determine which session to terminate when comms are done via back channel
  Rather the service depends on a shared session identifier ( sid ) from ID and Logout tokens
* Logout tokens are generated by Auth0 when a session is destroyed via /logout or session revocation
* Apps must register a back channel callback URL for this to work so Auth0 knows what apps to call when logout occurs
* If one app logs out with Auth0 then Auth0 will log out of all other registered apps via callbacks
* Flow
  1. Login - During user authentication with apps, the Auth0 tenant provides ID token with with sid and uid (session id and user id)
  2. Login - App stores the received session identifier in its own session store and associates it with the application-specific session
  3. Logout - Auth0 calls the pre-registered logout callback URL and posts the Logout Token to this endpoint. 
     The token contains the uid and the sid along with other parameters
  4. Logout - The application’s backend needs to validate the Logout Token as per OIDC spec and extract the sid. Then the 
     backend can use this token to find the session associated with the identifier and terminate it as necessary
* Limitations
  * Apps must be able to store sid
  * Apps can verify JWT tokens
  * Apps only accept tokens by trusted tenants
  * Apps must only accept tokens with sid
  * Apps must expose callback endpoints only via TLS
  * Apps recommended to only accept requests from published list of outbound IP addresses
  * Apps provide rate limiting
  * Any changes to endpoint address must be synce with Auth0 tenant

## Configure cross-origin authentication

## Set up authentication profile

## Understand and Implement Authentication APIs

## Implement JWT token validation using JWKS

# Authentication - Provisioning users