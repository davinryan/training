# Security

* Progressive enrollment - invite users to add a passkey after a successful login
* Challenge policy - prompt users to use a passkey when device support is detected

## Implement multi-factor authentication policies
* Location: Dashboard > Security > Multi-factor Auth > Factors
* Reset users MFA
  * Dashboard > User Management > users > user > Actions
  * Dashboard > Security > Multi-factor Auth (Turn off)
  * Management API - delete MFA enrollments
    * DELETE `api/v2/users/{userId}/authentication-methods` endpoint removes **ONE** of the enrollments
    * DELETE `api/v2/users/{userId}/authenticators` removes **ALL** authenticator apps such as the Auth0 Guardian app or Google Authenticator.
* Note: First factor logins do not require MFA
  * e.g. Passwordless and Passkeys are all considered first factor or independent
* Independent Factors do not require other MFA factors
* Independent Factors
  * Push notifications (Guardian app only)
  * SMS notifications
  * Voice notifications
  * One time passwords (OTP)
  * Cisco Due security
  * WebAuthn with security keys - e.g. Yubikey, Google Titan
* Dependent factors 
  * Recovery codes
  * WebAuthn with biometrics
  * Email notifications
* Defaults
  * Auth0 presents the most secure authentication factors to users upon enrollment. 
    To disable it, toggle on 'Show Multi-factor Authentication options'
* Actions - can allow MFA per user or application

### WebAuthN
* can be triggered via actions
* Keys that are tied to devices
* AAL3 compliant
* phishing-resistant - due to private key never leaving device
* Basically using asynchronous cryptographic key generation. Private key on the device, public key on the server
* Each device is bound using
  * user
  * device
  * origin
* Platform authenticators: Windows Hello, Touch ID
  * Roaming authenticators: Yubikey, Goodle Titan Key
* Can operate as passwordless or MFA
  * Passwordless WebAuth
    * Prompt timing - prompted first, replaces password
    * Purpose - Passwordless login
    * Example - Touch your security key to sign in
  * MFA WebAuth
    * Prompt timing - prompted after login
    * Purpose - Second factor (AAL2/AAL3)
    * Example - Enter password -> Touch your key
  * New Device / First Use
    * Prompt Timing - not auto-prompted before authentication
    * Purpose - Must enrol a new credential after identity has been verified
    * Example - Register device key after first login
* Key Takeaways
  * WebAuthN is part of FIDO2 and uses public-key crytography for phishing resistant logins
  * It can operate as passwordless (after first login) or MFA depending on configuration
  * Each credential is unique to a device; new devices require new enrollment
  * WebAuthN authenticators meet the highest Authentication Assurance Level (AAL3)

### Adaptive MFA (enterprise only)
* Location: Dashboard > Security > Multifactor Auth > Define Policies
* When: during login 
* NOTE: for some reason Auth0 doesn't count this as Step-up Auth but we all know it is, just based on risk
* Options
  * On - MFA when high risk login activity is detected
  * Always - MFA is always required
  * Never - MFA is never required
* Limitations
  * Pain in the arse to test as you never know when it will kick in
  * Score based on
    * New Device - not been used in 30 days
    * ImpossibleTravel - user attempted to login from location that would be impossible to travel to since last login
      * Actions: event.authentication.riskAssessment.assessments.ImpossibleTravel
    * UntrustedIP - IP that's on a list bad behaviour list
  * If not enrolled in MFA user gets an email challenge
  * Not supported for
    * Basically any flows that do not make email available like passwordless SMS and some of the following
    * Client credentials flow
    * Device Authorisation flow (unless using Universal login)
    * Resource owner flow (unless you use auth0-forwarded-for header)
    * SAML IdP initiated login
    * Only available for social connections that provide an email address (to allow alternative MFA flow)
  * You can extend behaviour with action – Perform action if the overall score is X
    ```javascript
    exports.onExecutePostLogin = async (event, api) => {
      const {riskAssessment} = event.authentication || {};
      const riskIsMedium = riskAssessment && riskAssessment.confidence === 'medium';
 
      if (riskIsMedium) {
          // ....
      }
    }     
    ```
    
### Step up Authentication
* When: post login
* Reasons
  * limit access to parts of website for paying users
  * require higher level of assurance when users attempt to access sensitive resources
* 'Step up authentication' via webapp (Really bad approach - but simple to implement)
  1. User tries to do something risky like transfer funds
  2. App checks to see if they have logged in with MFA by reviewing claims in ID token
* 'Step up authentication' via scopes with Actions
  * requires 
    * scopes, actions and access token
    * app registered; database connection; API registered; MFA enabled on tenant
    * validate tokens signature and standard claims
    * create post-login action to check user's ID Token for amr claim to have mfa
  * 'Customise MFA factors using actions' ensures verification logic will be available using extensible methods in actions
  1. Initial login asks for scope read:accounts
  2. User then want to do something risky like transfer:funds
  3. Check if ID token 'amr' claim equals 'mfa' (already passed MFA) - only works when not using RBAC and access token returns all scopes available
  4. If step 3 does apply and pass, flow ends here and app authorises using access token claims from initial login
     If step 3 doesn't apply - continue
  5. Needs to call /authorize with scope transfer:funds to ask for it
  6. Post-login Action intercepts this and asks for MFA
  * E.g. step up if view:balance or transfer:funds required and hasn't passed MFA challenge
  ```javascript
  exports.onExecutePostLogin = async (event, api) => {
    const needsHighValue = (event.authorization?.requested_permissions || []).some(p =>
      ['view:balance', 'transfer:funds'].includes(p)
    );
    const hasMfa = (event.authentication?.methods || []).some(m => m.name === 'mfa') 
                   || (event.user.multifactor && event.user.multifactor.length > 0);
  
    if (needsHighValue && !hasMfa) {
      api.multifactor.enable('any');
      // Optionally short-circuit issuing the high-value scopes until MFA is completed
      api.accessToken.setCustomClaim('https://example.com/high_value_pending', true);
    }
  };
  ```
  
### Management
* B2B - Customers manage MFA for their users
* B2C - End users manage MFA via profile page
* B2E - Company (you) manage MFA for your users
* Get factors for user
  ```bash
  curl --request GET \
    --url 'https://{yourDomain}/mfa/authenticators' \
    --header 'authorization: Bearer MFA_TOKEN'
  ```

## Set up attack protection
* Location: Dashboard > Security > Attack Protection
* Notification customisation location: Dashbaord > Branding > Email Templates
* Types of attacks (from user perspective)
  * Fraudulent registrations - creations of fake accounts
  * Credential stuffing - using known breached username and password pairs to get access to accounts
  * MFA Bypass attacks - using social engineering or brute force to avoid/circumvent MFA
  * Breached passwords - Stolen username/password pairs via Phishing, scames, insecure storage or weak passwords
  * MFA Fatigue - push bombing, occurs when attackers span a user's mobile device with login notifications hoping they 
    will approve on out of frustration
* Types of attack protection
  * Brute Force Protection - prevents brute force attacks from same IP address for a single user
  * Bot Detection - detects scripted attacks from bots, triggers verification step based on bot detection level
  * Suspicious IP Throttling - protects from denial of service attacks from any IP address that rapidly attempts too 
    many logins or signups
  * Breached Password Detection - Detects breached passwords in username/password pairs from public data sources
  
### Brute-Force Protection
* Prevents brute force attacks from same IP address for a single user
* Location: Dashboard > Security > Attack Protection > Brute Force Protection
* As usual you'll be in monitoring mode if you do not enable this feature
* Default: Enabled
* Has IP AllowList
* When blocked
  * IP added to blocked list
  * 429 response returned from now on
  * Sends notifications to affected users when detected
* When IP is blocked automatically it remains blocked until 
  * admin removes block
  * admin raises brute force threshold
  * 30 days passes
  * affected user selects unblock link in email notification (if configured) - allows user to change their password
  * affected user changes their password (on all linked accounts)
* Will run in monitoring mode if you do not specify a Response
* Responses
  * Block Brute-force login attempts - blocks IP address
  * Account Lock out - blocks account regardless of IP address
  * Send notification to affected users - SMS, EMail
* Special cases
  * Resource Owner password flow - requires setting auth0-forwarded-for header as all logins will appear to come from same server IP
  * Proxies & Shared IP Addresses (VPNs) - same issues as resource owner but you can whitelist these IP addresses using 
    a subnet range / CIDR range

### Suspicious IP Throttling
* Prevents denial of service attacks from any IP address that rapidly attempts too many logins or signups
* Location: Dashboard > Security > Attack Protection > Suspicious IP Throttling
* As usual you'll be in monitoring mode if you do not enable this feature
* Default: enabled
* Configuration
  * Max attempts (default: login - 100, signup - 50/day) - over 24 hours
  * Throttling rate (default: login - 100, signup - 72000/day) - how many attempts per 24 hours e.g. 100 = 1 attempt every 15 minutes
  * Response
    * Block settings - block if triggered 
    * Notifications – emails sent to administrators when throttling detected

### Breached Password Detection
* Takes action when use of breached passwords is detected
* Location: Dashboard > Security > Attack Protection > Breached Password Detection
* Default: Disabled
* As usual you'll be in monitoring mode if you do not enable this feature
* 3 ways
  * Bock new users from signing up with compromised credentials
  * Block users from logging in with compromised credentials
  * Send email notification to affected users allowing them to change their password
* Configuration
  * Detection method
    * Credential Guard - uses dark web, researches, more active methods to detect breached passwords (unkown lag)
    * When published - uses public data sources to detect breached passwords (12-36 hour lag)
  * Response
    * Block compromised credentials upon signup
    * Block compromised credentials upon password reset
    * Block compromised credentials upon login
  * Notifications
    * Send and email for each of the above responses
    * Send admin email about
      * accounts created with compromised credentials
      * accounts logging in with compromised credentials
      * frequency: immediately, daily, weekly, monthly
* Testing - Auth0 provides test credentials for breached password detection
  * Signup,login - Password = Paaf213XXYYZZ, Paat739!!WWXXYYZZ or any password starting with AUTH0-TEST-
    * Monitoring - go to logs to find 
      * signup: signup_pwd_leak events
      * login: pwd_leak
      * password change: reset_pwd_leak
  

## Configure password complexity rules
* See 'Database (Password)' in 2.authentication.md
  * Length, complexity
  * History - remembers up to last 24 passwords
  * Dictionary - can restrict users from using dumb passwords using an Auth0 password dictionary plus custom entries
  * Disallow personal data - can restrict users from using data from their profile

## Set up anomaly detection actions
* Add Auth0 actions to be triggered when anomalous login activity is detected - no information was available on this

## Implement CAPTCHA or reCAPTCHA
### Bot Detection
* Defend against fake user accounts signups
* As usual you'll be in monitoring mode if you do not enable this feature
* Location: Dashboard > Security > Attack Protection > Bot Detection
  1. Enable Tenant logs for Risk Assessment
  2. Choose a response
  3. Choose when to prompt for CAPTCHA: Never, When Risky, Always 
    * use 'Always' for passwordless flows
    * use 'When Risky' for password reset flow
  4. Choose Bot Detection level: Low; Medium (default), High (secret sauce, Auth0 doesn't explain this)
    * Higher bot detection levels create more friction for the user 
* If you do not provide a response, then Bot Detection will just monitor. Good for trialling/testing
* Responses
  * Auth Challenge (Default)
    * Strong privacy and good user experience
    * Requires Javascript enabled in browser
  * Simple CAPTCHA
  * Google reCAPTCHA v2
  * reCAPTCHA Enterprise
  * hCaptcha
  * Friendly Captcha
  * Arkose Labs
* Detection Models (for Classic and custom login pages)
  * Ensure SDKs (Auth0.js, Lock) used are latest versions
* Fail Open toggle
  * False (default) - if bot detection server cannot be reached, then authentication/login will not advance
  * True - if bot detection server cannot be reached, an error will be returned and user can continue authentication 
    without completing a challenge
* Limitations
  * Works for Universal Login
  * Requires javascript enabled in browser
    * If no Javascript enabled - then Simple CAPTCHA recommended
  * Classic and Custom Logins are mostly covered 
    * only supported for custom login pages hosted by Auth0 
    * if using latest versions of Auth0.js and Lock
    * Not supported - if performing cross origin authentication
  * Regular web or native apps using resource owner password flow are not supported unless you trigger a web based 
    login flow to complete authentication and pass a captcha step 
  * Some connections are not supported
    * Enterprise
    * Social
    * Passwordless - supported if compatible web based flow is used (see limitations above)
    
## Set up password history and reuse policies
* See 'Database (Password)' in 2.authentication.md

## Set up passwordless authentication
* If embedded - POST to the following
  * POST /passwordless/start to send the email or SMS.
  * POST /passwordless/verify to complete the login
* See 'Passwordless' and 'Biometrics in 2.authentication.md
* Requires 'Identifier first' Authentication profile
* After a user logs in with username/password and enroll their device, next time they just provide
  1. Their email address / username
  2. Prompted for biometrics login (or sent SMS or email for passwordless or passkey)

## Built in Auth0 defense against fundamental web application attacks

### Cross-Site Request Forgery (CSRF)
In an OAuth 2.0 context, a CSRF attack could involve an attacker tricking an already authenticated user into authorising 
the attacker’s account, linking the victim’s data to the attacker. The state parameter is the primary defence. The client 
application must generate a unique, unpredictable value for the state parameter and store it locally 
(e.g. in the user’s session) before redirecting to Auth0. Auth0 will include this exact value in the redirect back to 
the application. The application must then verify that the returned state parameter matches the value it originally 
stored. A mismatch indicates a potential CSRF attack, and the authentication response must be rejected

### Replay Attacks
A replay attack occurs when an attacker captures a valid token and reuses it to impersonate the user. For ID tokens, 
the nonce parameter is the defence. Similar to state, the application generates a unique value for nonce and sends it 
in the authentication request. Auth0 then includes this same nonce value as a claim inside the signed ID token. The 
application must verify that the nonce claim in the received ID token matches the value it sent for that specific 
request. This ensures the token was freshly generated for the current transaction and is not a replayed token from a 
previous one. The use of the nonce parameter is required when using the Implicit Flow